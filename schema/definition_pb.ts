// @generated by protobuf-ts 2.7.0 with parameter force_disable_services,add_pb_suffix,force_exclude_all_options
// @generated from protobuf file "schema/definition.proto" (package "foundation.schema", syntax proto3)
// tslint:disable
//
// Copyright 2022 Namespace Labs Inc; All rights reserved.
// Licensed under the EARLY ACCESS SOFTWARE LICENSE AGREEMENT
// available at http://github.com/namespacelabs/foundation
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../google/protobuf/any_pb";
/**
 * A definition represents a serialized invocation. It captures the arguments
 * for a method which is registered by an implementation. It thus provides a
 * form of decoupling, and allows for a frontend/backend design, with separate
 * planning/execution phases.
 *
 * @generated from protobuf message foundation.schema.SerializedInvocation
 */
export interface SerializedInvocation {
    /**
     * Human readable description of the definition, does not affect output.
     * Presented to the user on invocation.
     *
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * The list of packages this invocation applies to. Purely informational,
     * does not affect output.
     *
     * @generated from protobuf field: repeated string scope = 3;
     */
    scope: string[];
    /**
     * Arguments to the method. The type of the arguments is used to select the
     * method implementation.
     *
     * @generated from protobuf field: google.protobuf.Any impl = 2;
     */
    impl?: Any;
    /**
     * Computed arguments that may be used by the implementation.
     *
     * @generated from protobuf field: repeated foundation.schema.SerializedInvocation.ComputedValue computed = 4;
     */
    computed: SerializedInvocation_ComputedValue[];
}
/**
 * @generated from protobuf message foundation.schema.SerializedInvocation.ComputedValue
 */
export interface SerializedInvocation_ComputedValue {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: google.protobuf.Any value = 2;
     */
    value?: Any;
}
/**
 * An invocation that requires compilation, and will yield a SerializedInvocation.
 *
 * @generated from protobuf message foundation.schema.SerializedInvocationSource
 */
export interface SerializedInvocationSource {
    /**
     * Human readable description of the definition, does not affect output.
     * Presented to the user on invocation.
     *
     * @generated from protobuf field: string description = 1;
     */
    description: string;
    /**
     * The list of packages this invocation applies to. Purely informational,
     * does not affect output.
     *
     * @generated from protobuf field: repeated string scope = 2;
     */
    scope: string[];
    /**
     * Arguments to the method. The type of the arguments is used to select the
     * method implementation.
     *
     * @generated from protobuf field: google.protobuf.Any impl = 3;
     */
    impl?: Any;
    /**
     * Arguments to be computed to pass to the SerializedInvocation.
     *
     * @generated from protobuf field: repeated foundation.schema.SerializedInvocationSource.ComputableValue computable = 4;
     */
    computable: SerializedInvocationSource_ComputableValue[];
}
/**
 * @generated from protobuf message foundation.schema.SerializedInvocationSource.ComputableValue
 */
export interface SerializedInvocationSource_ComputableValue {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: google.protobuf.Any value = 2;
     */
    value?: Any;
}
/**
 * @generated from protobuf message foundation.schema.SerializedProgram
 */
export interface SerializedProgram {
    /**
     * @generated from protobuf field: repeated foundation.schema.SerializedInvocation invocation = 1;
     */
    invocation: SerializedInvocation[];
}
/**
 * Computed configurations are used to then project runtime-specific
 * configuration, such as flags, env vars, etc. Computed configurations are
 * emitted by provisioning tools, and retained in config images. They're used to
 * be able to retain the intersection of implementation version and
 * configuration inputs. Rather than having implementations recompute these
 * values, and have to keep track of versions, a fully denormalized version is
 * retained instead.
 *
 * @generated from protobuf message foundation.schema.ComputedConfiguration
 */
export interface ComputedConfiguration {
    /**
     * A package name that represents who computed this configuration.
     *
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * A domain-specific message which encapsulates a computed configuration.
     *
     * @generated from protobuf field: google.protobuf.Any impl = 2;
     */
    impl?: Any;
}
/**
 * @generated from protobuf message foundation.schema.ComputedConfigurations
 */
export interface ComputedConfigurations {
    /**
     * @generated from protobuf field: repeated foundation.schema.ComputedConfigurations.Entry entry = 1;
     */
    entry: ComputedConfigurations_Entry[];
}
/**
 * @generated from protobuf message foundation.schema.ComputedConfigurations.Entry
 */
export interface ComputedConfigurations_Entry {
    /**
     * @generated from protobuf field: string server_package = 1;
     */
    serverPackage: string; // Which server owns these configurations.
    /**
     * @generated from protobuf field: repeated foundation.schema.ComputedConfiguration configuration = 2;
     */
    configuration: ComputedConfiguration[];
}
// @generated message type with reflection information, may provide speed optimized methods
class SerializedInvocation$Type extends MessageType<SerializedInvocation> {
    constructor() {
        super("foundation.schema.SerializedInvocation", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scope", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "impl", kind: "message", T: () => Any },
            { no: 4, name: "computed", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SerializedInvocation_ComputedValue }
        ]);
    }
    create(value?: PartialMessage<SerializedInvocation>): SerializedInvocation {
        const message = { description: "", scope: [], computed: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SerializedInvocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SerializedInvocation): SerializedInvocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* repeated string scope */ 3:
                    message.scope.push(reader.string());
                    break;
                case /* google.protobuf.Any impl */ 2:
                    message.impl = Any.internalBinaryRead(reader, reader.uint32(), options, message.impl);
                    break;
                case /* repeated foundation.schema.SerializedInvocation.ComputedValue computed */ 4:
                    message.computed.push(SerializedInvocation_ComputedValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SerializedInvocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* repeated string scope = 3; */
        for (let i = 0; i < message.scope.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.scope[i]);
        /* google.protobuf.Any impl = 2; */
        if (message.impl)
            Any.internalBinaryWrite(message.impl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.SerializedInvocation.ComputedValue computed = 4; */
        for (let i = 0; i < message.computed.length; i++)
            SerializedInvocation_ComputedValue.internalBinaryWrite(message.computed[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.SerializedInvocation
 */
export const SerializedInvocation = new SerializedInvocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SerializedInvocation_ComputedValue$Type extends MessageType<SerializedInvocation_ComputedValue> {
    constructor() {
        super("foundation.schema.SerializedInvocation.ComputedValue", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<SerializedInvocation_ComputedValue>): SerializedInvocation_ComputedValue {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SerializedInvocation_ComputedValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SerializedInvocation_ComputedValue): SerializedInvocation_ComputedValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any value */ 2:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SerializedInvocation_ComputedValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any value = 2; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.SerializedInvocation.ComputedValue
 */
export const SerializedInvocation_ComputedValue = new SerializedInvocation_ComputedValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SerializedInvocationSource$Type extends MessageType<SerializedInvocationSource> {
    constructor() {
        super("foundation.schema.SerializedInvocationSource", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scope", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "impl", kind: "message", T: () => Any },
            { no: 4, name: "computable", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SerializedInvocationSource_ComputableValue }
        ]);
    }
    create(value?: PartialMessage<SerializedInvocationSource>): SerializedInvocationSource {
        const message = { description: "", scope: [], computable: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SerializedInvocationSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SerializedInvocationSource): SerializedInvocationSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* repeated string scope */ 2:
                    message.scope.push(reader.string());
                    break;
                case /* google.protobuf.Any impl */ 3:
                    message.impl = Any.internalBinaryRead(reader, reader.uint32(), options, message.impl);
                    break;
                case /* repeated foundation.schema.SerializedInvocationSource.ComputableValue computable */ 4:
                    message.computable.push(SerializedInvocationSource_ComputableValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SerializedInvocationSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* repeated string scope = 2; */
        for (let i = 0; i < message.scope.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.scope[i]);
        /* google.protobuf.Any impl = 3; */
        if (message.impl)
            Any.internalBinaryWrite(message.impl, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.SerializedInvocationSource.ComputableValue computable = 4; */
        for (let i = 0; i < message.computable.length; i++)
            SerializedInvocationSource_ComputableValue.internalBinaryWrite(message.computable[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.SerializedInvocationSource
 */
export const SerializedInvocationSource = new SerializedInvocationSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SerializedInvocationSource_ComputableValue$Type extends MessageType<SerializedInvocationSource_ComputableValue> {
    constructor() {
        super("foundation.schema.SerializedInvocationSource.ComputableValue", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<SerializedInvocationSource_ComputableValue>): SerializedInvocationSource_ComputableValue {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SerializedInvocationSource_ComputableValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SerializedInvocationSource_ComputableValue): SerializedInvocationSource_ComputableValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any value */ 2:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SerializedInvocationSource_ComputableValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any value = 2; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.SerializedInvocationSource.ComputableValue
 */
export const SerializedInvocationSource_ComputableValue = new SerializedInvocationSource_ComputableValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SerializedProgram$Type extends MessageType<SerializedProgram> {
    constructor() {
        super("foundation.schema.SerializedProgram", [
            { no: 1, name: "invocation", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SerializedInvocation }
        ]);
    }
    create(value?: PartialMessage<SerializedProgram>): SerializedProgram {
        const message = { invocation: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SerializedProgram>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SerializedProgram): SerializedProgram {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.SerializedInvocation invocation */ 1:
                    message.invocation.push(SerializedInvocation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SerializedProgram, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.SerializedInvocation invocation = 1; */
        for (let i = 0; i < message.invocation.length; i++)
            SerializedInvocation.internalBinaryWrite(message.invocation[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.SerializedProgram
 */
export const SerializedProgram = new SerializedProgram$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComputedConfiguration$Type extends MessageType<ComputedConfiguration> {
    constructor() {
        super("foundation.schema.ComputedConfiguration", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "impl", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ComputedConfiguration>): ComputedConfiguration {
        const message = { owner: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ComputedConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComputedConfiguration): ComputedConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* google.protobuf.Any impl */ 2:
                    message.impl = Any.internalBinaryRead(reader, reader.uint32(), options, message.impl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComputedConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* google.protobuf.Any impl = 2; */
        if (message.impl)
            Any.internalBinaryWrite(message.impl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.ComputedConfiguration
 */
export const ComputedConfiguration = new ComputedConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComputedConfigurations$Type extends MessageType<ComputedConfigurations> {
    constructor() {
        super("foundation.schema.ComputedConfigurations", [
            { no: 1, name: "entry", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ComputedConfigurations_Entry }
        ]);
    }
    create(value?: PartialMessage<ComputedConfigurations>): ComputedConfigurations {
        const message = { entry: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ComputedConfigurations>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComputedConfigurations): ComputedConfigurations {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.ComputedConfigurations.Entry entry */ 1:
                    message.entry.push(ComputedConfigurations_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComputedConfigurations, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.ComputedConfigurations.Entry entry = 1; */
        for (let i = 0; i < message.entry.length; i++)
            ComputedConfigurations_Entry.internalBinaryWrite(message.entry[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.ComputedConfigurations
 */
export const ComputedConfigurations = new ComputedConfigurations$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComputedConfigurations_Entry$Type extends MessageType<ComputedConfigurations_Entry> {
    constructor() {
        super("foundation.schema.ComputedConfigurations.Entry", [
            { no: 1, name: "server_package", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "configuration", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ComputedConfiguration }
        ]);
    }
    create(value?: PartialMessage<ComputedConfigurations_Entry>): ComputedConfigurations_Entry {
        const message = { serverPackage: "", configuration: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ComputedConfigurations_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComputedConfigurations_Entry): ComputedConfigurations_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string server_package */ 1:
                    message.serverPackage = reader.string();
                    break;
                case /* repeated foundation.schema.ComputedConfiguration configuration */ 2:
                    message.configuration.push(ComputedConfiguration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComputedConfigurations_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string server_package = 1; */
        if (message.serverPackage !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverPackage);
        /* repeated foundation.schema.ComputedConfiguration configuration = 2; */
        for (let i = 0; i < message.configuration.length; i++)
            ComputedConfiguration.internalBinaryWrite(message.configuration[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.ComputedConfigurations.Entry
 */
export const ComputedConfigurations_Entry = new ComputedConfigurations_Entry$Type();
