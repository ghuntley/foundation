// @generated by protobuf-ts 2.7.0 with parameter force_disable_services,add_pb_suffix,force_exclude_all_options
// @generated from protobuf file "schema/schema.proto" (package "foundation.schema", syntax proto3)
// tslint:disable
//
// Copyright 2022 Namespace Labs Inc; All rights reserved.
// Licensed under the EARLY ACCESS SOFTWARE LICENSE AGREEMENT
// available at http://github.com/namespacelabs/foundation
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Domain_ManagedType } from "./networking_pb";
import { ServiceMetadata } from "./networking_pb";
import { Endpoint_Port } from "./networking_pb";
import { BinaryConfig_EnvEntry } from "./binary_pb";
import { Any } from "../google/protobuf/any_pb";
import { Endpoint_Type } from "./networking_pb";
import { InternalEndpoint } from "./networking_pb";
import { Endpoint } from "./networking_pb";
/**
 * A schema file may include services and server; but initially we constraint
 * files to include exclusively one. That constraint is applied at `lint` time,
 * i.e. when the schema file is loaded.
 *
 * @generated from protobuf message foundation.schema.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: repeated foundation.schema.Node service = 1;
     */
    service: Node[];
    /**
     * @generated from protobuf field: repeated foundation.schema.Node extension = 2;
     */
    extension: Node[];
    /**
     * @generated from protobuf field: repeated foundation.schema.Server server = 3;
     */
    server: Server[];
}
/**
 * @generated from protobuf message foundation.schema.Stack
 */
export interface Stack {
    /**
     * @generated from protobuf field: repeated foundation.schema.Stack.Entry entry = 1;
     */
    entry: Stack_Entry[];
    /**
     * @generated from protobuf field: repeated foundation.schema.Endpoint endpoint = 2;
     */
    endpoint: Endpoint[];
    /**
     * @generated from protobuf field: repeated foundation.schema.InternalEndpoint internal_endpoint = 3;
     */
    internalEndpoint: InternalEndpoint[];
}
/**
 * @generated from protobuf message foundation.schema.Stack.Entry
 */
export interface Stack_Entry {
    /**
     * @generated from protobuf field: foundation.schema.Server server = 1;
     */
    server?: Server;
    /**
     * @generated from protobuf field: foundation.schema.Naming server_naming = 3;
     */
    serverNaming?: Naming;
    /**
     * @generated from protobuf field: repeated foundation.schema.Node node = 2;
     */
    node: Node[];
}
/**
 * This is temporary; without extensions protos are pretty monolithic.
 * And we don't want to be in a situation where all possible integrations
 * have to be known ahead of time.
 * Next ID: 19
 *
 * @generated from protobuf message foundation.schema.Node
 */
export interface Node {
    /**
     * The package name (computed).
     *
     * @generated from protobuf field: string package_name = 1;
     */
    packageName: string;
    /**
     * @generated from protobuf field: foundation.schema.Node.Kind kind = 2;
     */
    kind: Node_Kind;
    /**
     * The computed list of dependency URLs of this service (direct and indirect).
     *
     * @generated from protobuf field: repeated string import = 3;
     */
    import: string[];
    /**
     * Name used publicly.
     *
     * @generated from protobuf field: string ingress_service_name = 5;
     */
    ingressServiceName: string;
    /**
     * Singleton dependencies instantiated for this node.
     *
     * @generated from protobuf field: repeated foundation.schema.Instantiate instantiate = 6;
     */
    instantiate: Instantiate[];
    /**
     * A list of node needs (e.g. ports, etc).
     *
     * @generated from protobuf field: repeated foundation.schema.Need need = 7;
     */
    need: Need[];
    /**
     * Declarations of instance types this node provides.
     *
     * @generated from protobuf field: repeated foundation.schema.Provides provides = 8;
     */
    provides: Provides[];
    /**
     * Service nodes export services. This is embedded in the schema now but
     * may become dependencies in the future, i.e. an exported service
     * is kind of an instance of a declared gRPC service.
     *
     * @generated from protobuf field: repeated foundation.schema.GrpcExportService export_service = 9;
     */
    exportService: GrpcExportService[];
    /**
     * If set to true, these service's GRPC services are to be exported as HTTP
     * as well. Regardless of the ingress configuration here, these endpoints
     * will be public.
     *
     * @generated from protobuf field: bool export_services_as_http = 17;
     */
    exportServicesAsHttp: boolean;
    /**
     * HTTP paths exported by this service.
     *
     * @generated from protobuf field: repeated foundation.schema.HttpPath export_http = 16;
     */
    exportHttp: HttpPath[];
    /**
     * Ingress can be used to configure whether a service is visible to the
     * internet (only valid for services).
     *
     * @generated from protobuf field: foundation.schema.Endpoint.Type ingress = 10;
     */
    ingress: Endpoint_Type;
    /**
     * Can't contain multiple initializers with the same "framework".
     * Not a map since "framework" will likely be broken down and converted to a message.
     *
     * @generated from protobuf field: repeated foundation.schema.NodeInitializer initializers = 11;
     */
    initializers: NodeInitializer[];
    /**
     * @generated from protobuf field: foundation.schema.Framework service_framework = 19;
     */
    serviceFramework: Framework;
    /**
     * @generated from protobuf field: repeated foundation.schema.Reference reference = 13;
     */
    reference: Reference[];
    /**
     * Set of dependencies specified explicitly by the user.
     *
     * @generated from protobuf field: repeated string user_imports = 14;
     */
    userImports: string[];
    /**
     * Framework-specific extensions.
     *
     * @generated from protobuf field: repeated google.protobuf.Any ext = 15;
     */
    ext: Any[];
    /**
     * Storage claims.
     *
     * @generated from protobuf field: repeated foundation.schema.RequiredStorage required_storage = 18;
     */
    requiredStorage: RequiredStorage[];
}
/**
 * @generated from protobuf enum foundation.schema.Node.Kind
 */
export enum Node_Kind {
    /**
     * @generated from protobuf enum value: KIND_UNSPECIFIED = 0;
     */
    KIND_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SERVICE = 1;
     */
    SERVICE = 1,
    /**
     * @generated from protobuf enum value: EXTENSION = 2;
     */
    EXTENSION = 2
}
/**
 * @generated from protobuf message foundation.schema.NodeInitializer
 */
export interface NodeInitializer {
    /**
     * @generated from protobuf field: foundation.schema.Framework framework = 1;
     */
    framework: Framework;
    /**
     * @generated from protobuf field: repeated string initialize_before = 2;
     */
    initializeBefore: string[]; // Package name.
    /**
     * @generated from protobuf field: repeated string initialize_after = 3;
     */
    initializeAfter: string[]; // Package name.
}
/**
 * @generated from protobuf message foundation.schema.HttpPath
 */
export interface HttpPath {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
}
/**
 * XXX needs are at odds with instanced nodes; both provide means for the node to
 * use data+behavior provided by another part of the system. Provides is a better
 * model as it's more flexible. Needs are a necessary level right now to get core
 * types instantiated (e.g. ports).
 *
 * @generated from protobuf message foundation.schema.Need
 */
export interface Need {
    /**
     * @generated from protobuf field: string cue_path = 1;
     */
    cuePath: string;
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "port";
        /**
         * @generated from protobuf field: foundation.schema.Need.Port port = 2;
         */
        port: Need_Port;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message foundation.schema.Need.Port
 */
export interface Need_Port {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message foundation.schema.Provides
 */
export interface Provides {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: foundation.schema.TypeDef type = 2;
     */
    type?: TypeDef;
    /**
     * @generated from protobuf field: repeated foundation.schema.Provides.AvailableIn available_in = 3;
     */
    availableIn: Provides_AvailableIn[];
    /**
     * Scoped dependencies instantiated for this provided type.
     *
     * @generated from protobuf field: repeated foundation.schema.Instantiate instantiate = 4;
     */
    instantiate: Instantiate[];
}
/**
 * @generated from protobuf message foundation.schema.Provides.AvailableIn
 */
export interface Provides_AvailableIn {
    /**
     * @generated from protobuf field: foundation.schema.Provides.AvailableIn.Go go = 1;
     */
    go?: Provides_AvailableIn_Go;
    /**
     * @generated from protobuf field: foundation.schema.Provides.AvailableIn.Web web = 2;
     */
    web?: Provides_AvailableIn_Web;
    /**
     * @generated from protobuf field: foundation.schema.Provides.AvailableIn.NodeJs nodejs = 3;
     */
    nodejs?: Provides_AvailableIn_NodeJs;
}
/**
 * @generated from protobuf message foundation.schema.Provides.AvailableIn.Go
 */
export interface Provides_AvailableIn_Go {
    /**
     * @generated from protobuf field: string package = 1;
     */
    package: string;
    /**
     * @generated from protobuf field: string type = 2;
     */
    type: string;
}
/**
 * @generated from protobuf message foundation.schema.Provides.AvailableIn.Web
 */
export interface Provides_AvailableIn_Web {
}
/**
 * @generated from protobuf message foundation.schema.Provides.AvailableIn.NodeJs
 */
export interface Provides_AvailableIn_NodeJs {
    /**
     * @generated from protobuf field: string import = 1;
     */
    import: string;
    /**
     * @generated from protobuf field: string type = 2;
     */
    type: string;
}
/**
 * @generated from protobuf message foundation.schema.TypeDef
 */
export interface TypeDef {
    /**
     * The type made available for configuration.
     *
     * @generated from protobuf field: string typename = 1;
     */
    typename: string;
    /**
     * Paths to the protos that define the types available as a provider. Paths
     * must be relative to the package.
     *
     * @generated from protobuf field: repeated string source = 2;
     */
    source: string[];
}
/**
 * @generated from protobuf message foundation.schema.GrpcExportService
 */
export interface GrpcExportService {
    /**
     * Paths to the protos that defines the service. Paths must be
     * relative to the package.
     *
     * @generated from protobuf field: repeated string proto = 1;
     */
    proto: string[];
    /**
     * The type of the service being exported.
     *
     * @generated from protobuf field: string proto_typename = 2;
     */
    protoTypename: string;
    /**
     * A subset of methods this implementation supports. If empty, the implementation supports all methods.
     *
     * @generated from protobuf field: repeated string method = 3;
     */
    method: string[];
}
/**
 * @generated from protobuf message foundation.schema.Reference
 */
export interface Reference {
    /**
     * @generated from protobuf field: foundation.schema.Reference.Kind kind = 1;
     */
    kind: Reference_Kind;
    /**
     * @generated from protobuf field: string cue_path = 2;
     */
    cuePath: string;
    /**
     * @generated from protobuf field: string image = 3;
     */
    image: string;
    /**
     * @generated from protobuf field: string package_name = 4;
     */
    packageName: string;
    /**
     * @generated from protobuf field: repeated string file_path = 5;
     */
    filePath: string[]; // Relative to the module's path.
}
/**
 * @generated from protobuf enum foundation.schema.Reference.Kind
 */
export enum Reference_Kind {
    /**
     * @generated from protobuf enum value: KIND_UNSPECIFIED = 0;
     */
    KIND_UNSPECIFIED = 0,
    /**
     * Uses `image`.
     *
     * @generated from protobuf enum value: IMAGE = 1;
     */
    IMAGE = 1,
    /**
     * Uses `package_name`.
     *
     * @generated from protobuf enum value: SERVER = 2;
     */
    SERVER = 2,
    /**
     * Uses `package_name`.
     *
     * @generated from protobuf enum value: SERVICE = 3;
     */
    SERVICE = 3,
    /**
     * Uses `file_path`.
     *
     * @generated from protobuf enum value: PROTO_DEPS = 4;
     */
    PROTO_DEPS = 4
}
/**
 * @generated from protobuf message foundation.schema.Server
 */
export interface Server {
    /**
     * The package name (computed).
     *
     * @generated from protobuf field: string package_name = 1;
     */
    packageName: string;
    /**
     * In order to decouple code location and production resources, we refer
     * to the service through it's ID; which must remain constant during the
     * life of the service.
     *
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * A name for a person-user to read and refer to.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * The computed list of dependency URLs of this server (direct and indirect).
     *
     * @generated from protobuf field: repeated string import = 4;
     */
    import: string[];
    /**
     * The parent repository that hosts this server's definition.
     *
     * @generated from protobuf field: string namespace_module = 5;
     */
    namespaceModule: string;
    /**
     * Framework-specific extensions.
     *
     * @generated from protobuf field: repeated google.protobuf.Any ext = 6;
     */
    ext: Any[];
    /**
     * All of the allocations performed in this server's dependency tree.
     *
     * @generated from protobuf field: repeated foundation.schema.Allocation allocation = 7;
     */
    allocation: Allocation[];
    /**
     * @generated from protobuf field: foundation.schema.Framework framework = 8;
     */
    framework: Framework;
    /**
     * @generated from protobuf field: bool is_stateful = 20;
     */
    isStateful: boolean;
    /**
     * @generated from protobuf field: foundation.schema.Server.Binary binary = 9;
     */
    binary?: Server_Binary;
    /**
     * @generated from protobuf field: repeated foundation.schema.Server.ServiceSpec service = 10;
     */
    service: Server_ServiceSpec[];
    /**
     * @generated from protobuf field: repeated foundation.schema.Server.ServiceSpec ingress = 11;
     */
    ingress: Server_ServiceSpec[];
    /**
     * @generated from protobuf field: repeated foundation.schema.Reference reference = 12;
     */
    reference: Reference[];
    /**
     * XXX temporary.
     *
     * @generated from protobuf field: repeated foundation.schema.BinaryConfig.EnvEntry static_env = 13;
     */
    staticEnv: BinaryConfig_EnvEntry[];
    /**
     * Set of dependencies specified explicitly by the user.
     *
     * @generated from protobuf field: repeated string user_imports = 14;
     */
    userImports: string[];
    /**
     * Set of URL prefixes this server declares supporting.
     *
     * @generated from protobuf field: repeated foundation.schema.Server.URLMapEntry url_map = 15;
     */
    urlMap: Server_URLMapEntry[];
    /**
     * A set of ports that this server exports and require no configuration.
     *
     * @generated from protobuf field: repeated foundation.schema.Endpoint.Port static_port = 16;
     */
    staticPort: Endpoint_Port[];
    /**
     * Aggregated from all nodes.
     *
     * @generated from protobuf field: repeated foundation.schema.RequiredStorage required_storage = 18;
     */
    requiredStorage: RequiredStorage[];
}
/**
 * @generated from protobuf message foundation.schema.Server.Binary
 */
export interface Server_Binary {
    /**
     * @generated from protobuf field: string prebuilt = 1;
     */
    prebuilt: string;
    /**
     * @generated from protobuf field: string package_name = 2;
     */
    packageName: string;
}
/**
 * @generated from protobuf message foundation.schema.Server.ServiceSpec
 */
export interface Server_ServiceSpec {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: foundation.schema.ServiceMetadata metadata = 2;
     */
    metadata?: ServiceMetadata;
    /**
     * @generated from protobuf field: foundation.schema.Endpoint.Port port = 3;
     */
    port?: Endpoint_Port;
    /**
     * @generated from protobuf field: bool internal = 4;
     */
    internal: boolean; // This service is of no relevance for development.
}
/**
 * @generated from protobuf message foundation.schema.Server.URLMapEntry
 */
export interface Server_URLMapEntry {
    /**
     * @generated from protobuf field: string path_prefix = 1;
     */
    pathPrefix: string;
    /**
     * @generated from protobuf field: string package_name = 2;
     */
    packageName: string;
    /**
     * @generated from protobuf field: string ingress_name = 3;
     */
    ingressName: string;
    /**
     * @generated from protobuf field: string kind = 4;
     */
    kind: string;
}
/**
 * Allocations for a tree of instanced values.
 *
 * @generated from protobuf message foundation.schema.Allocation
 */
export interface Allocation {
    /**
     * @generated from protobuf field: repeated foundation.schema.Allocation.Instance instance = 1;
     */
    instance: Allocation_Instance[];
}
/**
 * @generated from protobuf message foundation.schema.Allocation.Instance
 */
export interface Allocation_Instance {
    /**
     * The source of the allocation.
     *
     * @generated from protobuf field: string instance_owner = 1;
     */
    instanceOwner: string;
    /**
     * The owning package of the fields being instantiated.
     *
     * @generated from protobuf field: string package_name = 2;
     */
    packageName: string;
    /**
     * An unique name within the server for this allocation path.
     *
     * @generated from protobuf field: string alloc_name = 3;
     */
    allocName: string;
    /**
     * @generated from protobuf field: repeated foundation.schema.Instantiate instantiated = 4;
     */
    instantiated: Instantiate[];
    /**
     * Allocations that happen as a result of this allocation (e.g. an instance
     * of a dependency).
     *
     * @generated from protobuf field: repeated foundation.schema.Allocation downstream_allocation = 5;
     */
    downstreamAllocation: Allocation[];
}
/**
 * @generated from protobuf message foundation.schema.Instantiate
 */
export interface Instantiate {
    /**
     * @generated from protobuf field: string package_name = 3;
     */
    packageName: string;
    /**
     * @generated from protobuf field: string type = 4;
     */
    type: string;
    /**
     * A unique name used to refer and configure this dependency.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: google.protobuf.Any constructor = 2;
     */
    constructor?: Any;
}
/**
 * @generated from protobuf message foundation.schema.Environment
 */
export interface Environment {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string runtime = 2;
     */
    runtime: string; // E.g. kubernetes
    /**
     * @generated from protobuf field: foundation.schema.Environment.Purpose purpose = 3;
     */
    purpose: Environment_Purpose;
    /**
     * Typically only set for tests. Signals that this environment is single-use and not meant to be user serviceable.
     *
     * @generated from protobuf field: bool ephemeral = 4;
     */
    ephemeral: boolean;
}
/**
 * @generated from protobuf enum foundation.schema.Environment.Purpose
 */
export enum Environment_Purpose {
    /**
     * @generated from protobuf enum value: PURPOSE_UNKNOWN = 0;
     */
    PURPOSE_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: DEVELOPMENT = 1;
     */
    DEVELOPMENT = 1,
    /**
     * @generated from protobuf enum value: TESTING = 2;
     */
    TESTING = 2,
    /**
     * @generated from protobuf enum value: PRODUCTION = 3;
     */
    PRODUCTION = 3
}
/**
 * @generated from protobuf message foundation.schema.Platform
 */
export interface Platform {
    /**
     * Architecture field specifies the CPU architecture, for example
     * `amd64` or `ppc64`.
     *
     * @generated from protobuf field: string architecture = 1;
     */
    architecture: string;
    /**
     * OS specifies the operating system, for example `linux` or `windows`.
     *
     * @generated from protobuf field: string os = 2;
     */
    os: string;
    /**
     * @generated from protobuf field: string variant = 3;
     */
    variant: string;
}
/**
 * @generated from protobuf message foundation.schema.HttpExportedService
 */
export interface HttpExportedService {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * @generated from protobuf message foundation.schema.RequiredStorage
 */
export interface RequiredStorage {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string; // Package name.
    /**
     * @generated from protobuf field: string persistent_id = 2;
     */
    persistentId: string;
    /**
     * @generated from protobuf field: uint64 byte_count = 3;
     */
    byteCount: bigint;
    /**
     * @generated from protobuf field: string mount_path = 4;
     */
    mountPath: string;
}
/**
 * @generated from protobuf message foundation.schema.Naming
 */
export interface Naming {
    /**
     * @generated from protobuf field: string with_org = 1;
     */
    withOrg: string; // Allocate with the following organization.
    /**
     * @generated from protobuf field: repeated foundation.schema.Naming.AdditionalDomainName additional_user_specified = 2;
     */
    additionalUserSpecified: Naming_AdditionalDomainName[]; // If set, also configures the ingress with these domains.
    /**
     * @generated from protobuf field: repeated foundation.schema.Naming.AdditionalDomainName additional_tls_managed = 3;
     */
    additionalTlsManaged: Naming_AdditionalDomainName[]; // If set, both configures an ingress with these domains, and requests TLS certificate from Foundation.
}
/**
 * @generated from protobuf message foundation.schema.Naming.AdditionalDomainName
 */
export interface Naming_AdditionalDomainName {
    /**
     * @generated from protobuf field: string allocated_name = 1;
     */
    allocatedName: string;
    /**
     * @generated from protobuf field: string fqdn = 2;
     */
    fqdn: string;
}
/**
 * @generated from protobuf message foundation.schema.ComputedNaming
 */
export interface ComputedNaming {
    /**
     * @generated from protobuf field: foundation.schema.Naming source = 1;
     */
    source?: Naming;
    /**
     * @generated from protobuf field: string base_domain = 2;
     */
    baseDomain: string; // E.g. {org}.nscloud.dev
    /**
     * @generated from protobuf field: foundation.schema.Domain.ManagedType managed = 3;
     */
    managed: Domain_ManagedType;
}
/**
 * @generated from protobuf enum foundation.schema.Framework
 */
export enum Framework {
    /**
     * @generated from protobuf enum value: FRAMEWORK_UNSPECIFIED = 0;
     */
    FRAMEWORK_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: GO = 1;
     */
    GO = 1,
    /**
     * @generated from protobuf enum value: WEB = 2;
     */
    WEB = 2,
    /**
     * @generated from protobuf enum value: NODEJS = 3;
     */
    NODEJS = 3,
    /**
     * Only for servers
     *
     * @generated from protobuf enum value: OPAQUE = 4;
     */
    OPAQUE = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("foundation.schema.Schema", [
            { no: 1, name: "service", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Node },
            { no: 2, name: "extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Node },
            { no: 3, name: "server", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = { service: [], extension: [], server: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.Node service */ 1:
                    message.service.push(Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Node extension */ 2:
                    message.extension.push(Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Server server */ 3:
                    message.server.push(Server.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.Node service = 1; */
        for (let i = 0; i < message.service.length; i++)
            Node.internalBinaryWrite(message.service[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Node extension = 2; */
        for (let i = 0; i < message.extension.length; i++)
            Node.internalBinaryWrite(message.extension[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Server server = 3; */
        for (let i = 0; i < message.server.length; i++)
            Server.internalBinaryWrite(message.server[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stack$Type extends MessageType<Stack> {
    constructor() {
        super("foundation.schema.Stack", [
            { no: 1, name: "entry", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Stack_Entry },
            { no: 2, name: "endpoint", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint },
            { no: 3, name: "internal_endpoint", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InternalEndpoint }
        ]);
    }
    create(value?: PartialMessage<Stack>): Stack {
        const message = { entry: [], endpoint: [], internalEndpoint: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Stack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stack): Stack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.Stack.Entry entry */ 1:
                    message.entry.push(Stack_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Endpoint endpoint */ 2:
                    message.endpoint.push(Endpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.InternalEndpoint internal_endpoint */ 3:
                    message.internalEndpoint.push(InternalEndpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.Stack.Entry entry = 1; */
        for (let i = 0; i < message.entry.length; i++)
            Stack_Entry.internalBinaryWrite(message.entry[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Endpoint endpoint = 2; */
        for (let i = 0; i < message.endpoint.length; i++)
            Endpoint.internalBinaryWrite(message.endpoint[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.InternalEndpoint internal_endpoint = 3; */
        for (let i = 0; i < message.internalEndpoint.length; i++)
            InternalEndpoint.internalBinaryWrite(message.internalEndpoint[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Stack
 */
export const Stack = new Stack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stack_Entry$Type extends MessageType<Stack_Entry> {
    constructor() {
        super("foundation.schema.Stack.Entry", [
            { no: 1, name: "server", kind: "message", T: () => Server },
            { no: 3, name: "server_naming", kind: "message", T: () => Naming },
            { no: 2, name: "node", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Node }
        ]);
    }
    create(value?: PartialMessage<Stack_Entry>): Stack_Entry {
        const message = { node: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Stack_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stack_Entry): Stack_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* foundation.schema.Server server */ 1:
                    message.server = Server.internalBinaryRead(reader, reader.uint32(), options, message.server);
                    break;
                case /* foundation.schema.Naming server_naming */ 3:
                    message.serverNaming = Naming.internalBinaryRead(reader, reader.uint32(), options, message.serverNaming);
                    break;
                case /* repeated foundation.schema.Node node */ 2:
                    message.node.push(Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stack_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* foundation.schema.Server server = 1; */
        if (message.server)
            Server.internalBinaryWrite(message.server, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Naming server_naming = 3; */
        if (message.serverNaming)
            Naming.internalBinaryWrite(message.serverNaming, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Node node = 2; */
        for (let i = 0; i < message.node.length; i++)
            Node.internalBinaryWrite(message.node[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Stack.Entry
 */
export const Stack_Entry = new Stack_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Node$Type extends MessageType<Node> {
    constructor() {
        super("foundation.schema.Node", [
            { no: 1, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "enum", T: () => ["foundation.schema.Node.Kind", Node_Kind] },
            { no: 3, name: "import", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "ingress_service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "instantiate", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Instantiate },
            { no: 7, name: "need", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Need },
            { no: 8, name: "provides", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Provides },
            { no: 9, name: "export_service", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GrpcExportService },
            { no: 17, name: "export_services_as_http", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "export_http", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpPath },
            { no: 10, name: "ingress", kind: "enum", T: () => ["foundation.schema.Endpoint.Type", Endpoint_Type] },
            { no: 11, name: "initializers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NodeInitializer },
            { no: 19, name: "service_framework", kind: "enum", T: () => ["foundation.schema.Framework", Framework] },
            { no: 13, name: "reference", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Reference },
            { no: 14, name: "user_imports", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "ext", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 18, name: "required_storage", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RequiredStorage }
        ]);
    }
    create(value?: PartialMessage<Node>): Node {
        const message = { packageName: "", kind: 0, import: [], ingressServiceName: "", instantiate: [], need: [], provides: [], exportService: [], exportServicesAsHttp: false, exportHttp: [], ingress: 0, initializers: [], serviceFramework: 0, reference: [], userImports: [], ext: [], requiredStorage: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Node): Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string package_name */ 1:
                    message.packageName = reader.string();
                    break;
                case /* foundation.schema.Node.Kind kind */ 2:
                    message.kind = reader.int32();
                    break;
                case /* repeated string import */ 3:
                    message.import.push(reader.string());
                    break;
                case /* string ingress_service_name */ 5:
                    message.ingressServiceName = reader.string();
                    break;
                case /* repeated foundation.schema.Instantiate instantiate */ 6:
                    message.instantiate.push(Instantiate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Need need */ 7:
                    message.need.push(Need.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Provides provides */ 8:
                    message.provides.push(Provides.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.GrpcExportService export_service */ 9:
                    message.exportService.push(GrpcExportService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool export_services_as_http */ 17:
                    message.exportServicesAsHttp = reader.bool();
                    break;
                case /* repeated foundation.schema.HttpPath export_http */ 16:
                    message.exportHttp.push(HttpPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* foundation.schema.Endpoint.Type ingress */ 10:
                    message.ingress = reader.int32();
                    break;
                case /* repeated foundation.schema.NodeInitializer initializers */ 11:
                    message.initializers.push(NodeInitializer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* foundation.schema.Framework service_framework */ 19:
                    message.serviceFramework = reader.int32();
                    break;
                case /* repeated foundation.schema.Reference reference */ 13:
                    message.reference.push(Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string user_imports */ 14:
                    message.userImports.push(reader.string());
                    break;
                case /* repeated google.protobuf.Any ext */ 15:
                    message.ext.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.RequiredStorage required_storage */ 18:
                    message.requiredStorage.push(RequiredStorage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string package_name = 1; */
        if (message.packageName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.packageName);
        /* foundation.schema.Node.Kind kind = 2; */
        if (message.kind !== 0)
            writer.tag(2, WireType.Varint).int32(message.kind);
        /* repeated string import = 3; */
        for (let i = 0; i < message.import.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.import[i]);
        /* string ingress_service_name = 5; */
        if (message.ingressServiceName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ingressServiceName);
        /* repeated foundation.schema.Instantiate instantiate = 6; */
        for (let i = 0; i < message.instantiate.length; i++)
            Instantiate.internalBinaryWrite(message.instantiate[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Need need = 7; */
        for (let i = 0; i < message.need.length; i++)
            Need.internalBinaryWrite(message.need[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Provides provides = 8; */
        for (let i = 0; i < message.provides.length; i++)
            Provides.internalBinaryWrite(message.provides[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.GrpcExportService export_service = 9; */
        for (let i = 0; i < message.exportService.length; i++)
            GrpcExportService.internalBinaryWrite(message.exportService[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool export_services_as_http = 17; */
        if (message.exportServicesAsHttp !== false)
            writer.tag(17, WireType.Varint).bool(message.exportServicesAsHttp);
        /* repeated foundation.schema.HttpPath export_http = 16; */
        for (let i = 0; i < message.exportHttp.length; i++)
            HttpPath.internalBinaryWrite(message.exportHttp[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Endpoint.Type ingress = 10; */
        if (message.ingress !== 0)
            writer.tag(10, WireType.Varint).int32(message.ingress);
        /* repeated foundation.schema.NodeInitializer initializers = 11; */
        for (let i = 0; i < message.initializers.length; i++)
            NodeInitializer.internalBinaryWrite(message.initializers[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Framework service_framework = 19; */
        if (message.serviceFramework !== 0)
            writer.tag(19, WireType.Varint).int32(message.serviceFramework);
        /* repeated foundation.schema.Reference reference = 13; */
        for (let i = 0; i < message.reference.length; i++)
            Reference.internalBinaryWrite(message.reference[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated string user_imports = 14; */
        for (let i = 0; i < message.userImports.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.userImports[i]);
        /* repeated google.protobuf.Any ext = 15; */
        for (let i = 0; i < message.ext.length; i++)
            Any.internalBinaryWrite(message.ext[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.RequiredStorage required_storage = 18; */
        for (let i = 0; i < message.requiredStorage.length; i++)
            RequiredStorage.internalBinaryWrite(message.requiredStorage[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Node
 */
export const Node = new Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeInitializer$Type extends MessageType<NodeInitializer> {
    constructor() {
        super("foundation.schema.NodeInitializer", [
            { no: 1, name: "framework", kind: "enum", T: () => ["foundation.schema.Framework", Framework] },
            { no: 2, name: "initialize_before", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "initialize_after", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NodeInitializer>): NodeInitializer {
        const message = { framework: 0, initializeBefore: [], initializeAfter: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NodeInitializer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NodeInitializer): NodeInitializer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* foundation.schema.Framework framework */ 1:
                    message.framework = reader.int32();
                    break;
                case /* repeated string initialize_before */ 2:
                    message.initializeBefore.push(reader.string());
                    break;
                case /* repeated string initialize_after */ 3:
                    message.initializeAfter.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NodeInitializer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* foundation.schema.Framework framework = 1; */
        if (message.framework !== 0)
            writer.tag(1, WireType.Varint).int32(message.framework);
        /* repeated string initialize_before = 2; */
        for (let i = 0; i < message.initializeBefore.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.initializeBefore[i]);
        /* repeated string initialize_after = 3; */
        for (let i = 0; i < message.initializeAfter.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.initializeAfter[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.NodeInitializer
 */
export const NodeInitializer = new NodeInitializer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpPath$Type extends MessageType<HttpPath> {
    constructor() {
        super("foundation.schema.HttpPath", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HttpPath>): HttpPath {
        const message = { path: "", kind: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HttpPath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpPath): HttpPath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpPath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.HttpPath
 */
export const HttpPath = new HttpPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Need$Type extends MessageType<Need> {
    constructor() {
        super("foundation.schema.Need", [
            { no: 1, name: "cue_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "message", oneof: "type", T: () => Need_Port }
        ]);
    }
    create(value?: PartialMessage<Need>): Need {
        const message = { cuePath: "", type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Need>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Need): Need {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cue_path */ 1:
                    message.cuePath = reader.string();
                    break;
                case /* foundation.schema.Need.Port port */ 2:
                    message.type = {
                        oneofKind: "port",
                        port: Need_Port.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).port)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Need, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cue_path = 1; */
        if (message.cuePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cuePath);
        /* foundation.schema.Need.Port port = 2; */
        if (message.type.oneofKind === "port")
            Need_Port.internalBinaryWrite(message.type.port, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Need
 */
export const Need = new Need$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Need_Port$Type extends MessageType<Need_Port> {
    constructor() {
        super("foundation.schema.Need.Port", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Need_Port>): Need_Port {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Need_Port>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Need_Port): Need_Port {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Need_Port, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Need.Port
 */
export const Need_Port = new Need_Port$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Provides$Type extends MessageType<Provides> {
    constructor() {
        super("foundation.schema.Provides", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "message", T: () => TypeDef },
            { no: 3, name: "available_in", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Provides_AvailableIn },
            { no: 4, name: "instantiate", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Instantiate }
        ]);
    }
    create(value?: PartialMessage<Provides>): Provides {
        const message = { name: "", availableIn: [], instantiate: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Provides>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Provides): Provides {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* foundation.schema.TypeDef type */ 2:
                    message.type = TypeDef.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* repeated foundation.schema.Provides.AvailableIn available_in */ 3:
                    message.availableIn.push(Provides_AvailableIn.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Instantiate instantiate */ 4:
                    message.instantiate.push(Instantiate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Provides, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* foundation.schema.TypeDef type = 2; */
        if (message.type)
            TypeDef.internalBinaryWrite(message.type, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Provides.AvailableIn available_in = 3; */
        for (let i = 0; i < message.availableIn.length; i++)
            Provides_AvailableIn.internalBinaryWrite(message.availableIn[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Instantiate instantiate = 4; */
        for (let i = 0; i < message.instantiate.length; i++)
            Instantiate.internalBinaryWrite(message.instantiate[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Provides
 */
export const Provides = new Provides$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Provides_AvailableIn$Type extends MessageType<Provides_AvailableIn> {
    constructor() {
        super("foundation.schema.Provides.AvailableIn", [
            { no: 1, name: "go", kind: "message", T: () => Provides_AvailableIn_Go },
            { no: 2, name: "web", kind: "message", T: () => Provides_AvailableIn_Web },
            { no: 3, name: "nodejs", kind: "message", T: () => Provides_AvailableIn_NodeJs }
        ]);
    }
    create(value?: PartialMessage<Provides_AvailableIn>): Provides_AvailableIn {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Provides_AvailableIn>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Provides_AvailableIn): Provides_AvailableIn {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* foundation.schema.Provides.AvailableIn.Go go */ 1:
                    message.go = Provides_AvailableIn_Go.internalBinaryRead(reader, reader.uint32(), options, message.go);
                    break;
                case /* foundation.schema.Provides.AvailableIn.Web web */ 2:
                    message.web = Provides_AvailableIn_Web.internalBinaryRead(reader, reader.uint32(), options, message.web);
                    break;
                case /* foundation.schema.Provides.AvailableIn.NodeJs nodejs */ 3:
                    message.nodejs = Provides_AvailableIn_NodeJs.internalBinaryRead(reader, reader.uint32(), options, message.nodejs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Provides_AvailableIn, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* foundation.schema.Provides.AvailableIn.Go go = 1; */
        if (message.go)
            Provides_AvailableIn_Go.internalBinaryWrite(message.go, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Provides.AvailableIn.Web web = 2; */
        if (message.web)
            Provides_AvailableIn_Web.internalBinaryWrite(message.web, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Provides.AvailableIn.NodeJs nodejs = 3; */
        if (message.nodejs)
            Provides_AvailableIn_NodeJs.internalBinaryWrite(message.nodejs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Provides.AvailableIn
 */
export const Provides_AvailableIn = new Provides_AvailableIn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Provides_AvailableIn_Go$Type extends MessageType<Provides_AvailableIn_Go> {
    constructor() {
        super("foundation.schema.Provides.AvailableIn.Go", [
            { no: 1, name: "package", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Provides_AvailableIn_Go>): Provides_AvailableIn_Go {
        const message = { package: "", type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Provides_AvailableIn_Go>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Provides_AvailableIn_Go): Provides_AvailableIn_Go {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string package */ 1:
                    message.package = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Provides_AvailableIn_Go, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string package = 1; */
        if (message.package !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.package);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Provides.AvailableIn.Go
 */
export const Provides_AvailableIn_Go = new Provides_AvailableIn_Go$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Provides_AvailableIn_Web$Type extends MessageType<Provides_AvailableIn_Web> {
    constructor() {
        super("foundation.schema.Provides.AvailableIn.Web", []);
    }
    create(value?: PartialMessage<Provides_AvailableIn_Web>): Provides_AvailableIn_Web {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Provides_AvailableIn_Web>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Provides_AvailableIn_Web): Provides_AvailableIn_Web {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Provides_AvailableIn_Web, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Provides.AvailableIn.Web
 */
export const Provides_AvailableIn_Web = new Provides_AvailableIn_Web$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Provides_AvailableIn_NodeJs$Type extends MessageType<Provides_AvailableIn_NodeJs> {
    constructor() {
        super("foundation.schema.Provides.AvailableIn.NodeJs", [
            { no: 1, name: "import", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Provides_AvailableIn_NodeJs>): Provides_AvailableIn_NodeJs {
        const message = { import: "", type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Provides_AvailableIn_NodeJs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Provides_AvailableIn_NodeJs): Provides_AvailableIn_NodeJs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string import */ 1:
                    message.import = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Provides_AvailableIn_NodeJs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string import = 1; */
        if (message.import !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.import);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Provides.AvailableIn.NodeJs
 */
export const Provides_AvailableIn_NodeJs = new Provides_AvailableIn_NodeJs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeDef$Type extends MessageType<TypeDef> {
    constructor() {
        super("foundation.schema.TypeDef", [
            { no: 1, name: "typename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TypeDef>): TypeDef {
        const message = { typename: "", source: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TypeDef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeDef): TypeDef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string typename */ 1:
                    message.typename = reader.string();
                    break;
                case /* repeated string source */ 2:
                    message.source.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeDef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string typename = 1; */
        if (message.typename !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.typename);
        /* repeated string source = 2; */
        for (let i = 0; i < message.source.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.source[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.TypeDef
 */
export const TypeDef = new TypeDef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrpcExportService$Type extends MessageType<GrpcExportService> {
    constructor() {
        super("foundation.schema.GrpcExportService", [
            { no: 1, name: "proto", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "proto_typename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "method", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GrpcExportService>): GrpcExportService {
        const message = { proto: [], protoTypename: "", method: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GrpcExportService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrpcExportService): GrpcExportService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string proto */ 1:
                    message.proto.push(reader.string());
                    break;
                case /* string proto_typename */ 2:
                    message.protoTypename = reader.string();
                    break;
                case /* repeated string method */ 3:
                    message.method.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GrpcExportService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string proto = 1; */
        for (let i = 0; i < message.proto.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.proto[i]);
        /* string proto_typename = 2; */
        if (message.protoTypename !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.protoTypename);
        /* repeated string method = 3; */
        for (let i = 0; i < message.method.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.method[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.GrpcExportService
 */
export const GrpcExportService = new GrpcExportService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reference$Type extends MessageType<Reference> {
    constructor() {
        super("foundation.schema.Reference", [
            { no: 1, name: "kind", kind: "enum", T: () => ["foundation.schema.Reference.Kind", Reference_Kind] },
            { no: 2, name: "cue_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "image", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "file_path", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Reference>): Reference {
        const message = { kind: 0, cuePath: "", image: "", packageName: "", filePath: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Reference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reference): Reference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* foundation.schema.Reference.Kind kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* string cue_path */ 2:
                    message.cuePath = reader.string();
                    break;
                case /* string image */ 3:
                    message.image = reader.string();
                    break;
                case /* string package_name */ 4:
                    message.packageName = reader.string();
                    break;
                case /* repeated string file_path */ 5:
                    message.filePath.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* foundation.schema.Reference.Kind kind = 1; */
        if (message.kind !== 0)
            writer.tag(1, WireType.Varint).int32(message.kind);
        /* string cue_path = 2; */
        if (message.cuePath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cuePath);
        /* string image = 3; */
        if (message.image !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.image);
        /* string package_name = 4; */
        if (message.packageName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.packageName);
        /* repeated string file_path = 5; */
        for (let i = 0; i < message.filePath.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.filePath[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Reference
 */
export const Reference = new Reference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Server$Type extends MessageType<Server> {
    constructor() {
        super("foundation.schema.Server", [
            { no: 1, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "import", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "namespace_module", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "ext", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 7, name: "allocation", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Allocation },
            { no: 8, name: "framework", kind: "enum", T: () => ["foundation.schema.Framework", Framework] },
            { no: 20, name: "is_stateful", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "binary", kind: "message", T: () => Server_Binary },
            { no: 10, name: "service", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server_ServiceSpec },
            { no: 11, name: "ingress", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server_ServiceSpec },
            { no: 12, name: "reference", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Reference },
            { no: 13, name: "static_env", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BinaryConfig_EnvEntry },
            { no: 14, name: "user_imports", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "url_map", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Server_URLMapEntry },
            { no: 16, name: "static_port", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint_Port },
            { no: 18, name: "required_storage", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RequiredStorage }
        ]);
    }
    create(value?: PartialMessage<Server>): Server {
        const message = { packageName: "", id: "", name: "", import: [], namespaceModule: "", ext: [], allocation: [], framework: 0, isStateful: false, service: [], ingress: [], reference: [], staticEnv: [], userImports: [], urlMap: [], staticPort: [], requiredStorage: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Server>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Server): Server {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string package_name */ 1:
                    message.packageName = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* repeated string import */ 4:
                    message.import.push(reader.string());
                    break;
                case /* string namespace_module */ 5:
                    message.namespaceModule = reader.string();
                    break;
                case /* repeated google.protobuf.Any ext */ 6:
                    message.ext.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Allocation allocation */ 7:
                    message.allocation.push(Allocation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* foundation.schema.Framework framework */ 8:
                    message.framework = reader.int32();
                    break;
                case /* bool is_stateful */ 20:
                    message.isStateful = reader.bool();
                    break;
                case /* foundation.schema.Server.Binary binary */ 9:
                    message.binary = Server_Binary.internalBinaryRead(reader, reader.uint32(), options, message.binary);
                    break;
                case /* repeated foundation.schema.Server.ServiceSpec service */ 10:
                    message.service.push(Server_ServiceSpec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Server.ServiceSpec ingress */ 11:
                    message.ingress.push(Server_ServiceSpec.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Reference reference */ 12:
                    message.reference.push(Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.BinaryConfig.EnvEntry static_env */ 13:
                    message.staticEnv.push(BinaryConfig_EnvEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string user_imports */ 14:
                    message.userImports.push(reader.string());
                    break;
                case /* repeated foundation.schema.Server.URLMapEntry url_map */ 15:
                    message.urlMap.push(Server_URLMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Endpoint.Port static_port */ 16:
                    message.staticPort.push(Endpoint_Port.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.RequiredStorage required_storage */ 18:
                    message.requiredStorage.push(RequiredStorage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Server, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string package_name = 1; */
        if (message.packageName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.packageName);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* repeated string import = 4; */
        for (let i = 0; i < message.import.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.import[i]);
        /* string namespace_module = 5; */
        if (message.namespaceModule !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.namespaceModule);
        /* repeated google.protobuf.Any ext = 6; */
        for (let i = 0; i < message.ext.length; i++)
            Any.internalBinaryWrite(message.ext[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Allocation allocation = 7; */
        for (let i = 0; i < message.allocation.length; i++)
            Allocation.internalBinaryWrite(message.allocation[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Framework framework = 8; */
        if (message.framework !== 0)
            writer.tag(8, WireType.Varint).int32(message.framework);
        /* bool is_stateful = 20; */
        if (message.isStateful !== false)
            writer.tag(20, WireType.Varint).bool(message.isStateful);
        /* foundation.schema.Server.Binary binary = 9; */
        if (message.binary)
            Server_Binary.internalBinaryWrite(message.binary, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Server.ServiceSpec service = 10; */
        for (let i = 0; i < message.service.length; i++)
            Server_ServiceSpec.internalBinaryWrite(message.service[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Server.ServiceSpec ingress = 11; */
        for (let i = 0; i < message.ingress.length; i++)
            Server_ServiceSpec.internalBinaryWrite(message.ingress[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Reference reference = 12; */
        for (let i = 0; i < message.reference.length; i++)
            Reference.internalBinaryWrite(message.reference[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.BinaryConfig.EnvEntry static_env = 13; */
        for (let i = 0; i < message.staticEnv.length; i++)
            BinaryConfig_EnvEntry.internalBinaryWrite(message.staticEnv[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated string user_imports = 14; */
        for (let i = 0; i < message.userImports.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.userImports[i]);
        /* repeated foundation.schema.Server.URLMapEntry url_map = 15; */
        for (let i = 0; i < message.urlMap.length; i++)
            Server_URLMapEntry.internalBinaryWrite(message.urlMap[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Endpoint.Port static_port = 16; */
        for (let i = 0; i < message.staticPort.length; i++)
            Endpoint_Port.internalBinaryWrite(message.staticPort[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.RequiredStorage required_storage = 18; */
        for (let i = 0; i < message.requiredStorage.length; i++)
            RequiredStorage.internalBinaryWrite(message.requiredStorage[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Server
 */
export const Server = new Server$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Server_Binary$Type extends MessageType<Server_Binary> {
    constructor() {
        super("foundation.schema.Server.Binary", [
            { no: 1, name: "prebuilt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Server_Binary>): Server_Binary {
        const message = { prebuilt: "", packageName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Server_Binary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Server_Binary): Server_Binary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prebuilt */ 1:
                    message.prebuilt = reader.string();
                    break;
                case /* string package_name */ 2:
                    message.packageName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Server_Binary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string prebuilt = 1; */
        if (message.prebuilt !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.prebuilt);
        /* string package_name = 2; */
        if (message.packageName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.packageName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Server.Binary
 */
export const Server_Binary = new Server_Binary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Server_ServiceSpec$Type extends MessageType<Server_ServiceSpec> {
    constructor() {
        super("foundation.schema.Server.ServiceSpec", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "message", T: () => ServiceMetadata },
            { no: 3, name: "port", kind: "message", T: () => Endpoint_Port },
            { no: 4, name: "internal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Server_ServiceSpec>): Server_ServiceSpec {
        const message = { name: "", internal: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Server_ServiceSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Server_ServiceSpec): Server_ServiceSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* foundation.schema.ServiceMetadata metadata */ 2:
                    message.metadata = ServiceMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* foundation.schema.Endpoint.Port port */ 3:
                    message.port = Endpoint_Port.internalBinaryRead(reader, reader.uint32(), options, message.port);
                    break;
                case /* bool internal */ 4:
                    message.internal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Server_ServiceSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* foundation.schema.ServiceMetadata metadata = 2; */
        if (message.metadata)
            ServiceMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Endpoint.Port port = 3; */
        if (message.port)
            Endpoint_Port.internalBinaryWrite(message.port, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool internal = 4; */
        if (message.internal !== false)
            writer.tag(4, WireType.Varint).bool(message.internal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Server.ServiceSpec
 */
export const Server_ServiceSpec = new Server_ServiceSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Server_URLMapEntry$Type extends MessageType<Server_URLMapEntry> {
    constructor() {
        super("foundation.schema.Server.URLMapEntry", [
            { no: 1, name: "path_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ingress_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Server_URLMapEntry>): Server_URLMapEntry {
        const message = { pathPrefix: "", packageName: "", ingressName: "", kind: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Server_URLMapEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Server_URLMapEntry): Server_URLMapEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path_prefix */ 1:
                    message.pathPrefix = reader.string();
                    break;
                case /* string package_name */ 2:
                    message.packageName = reader.string();
                    break;
                case /* string ingress_name */ 3:
                    message.ingressName = reader.string();
                    break;
                case /* string kind */ 4:
                    message.kind = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Server_URLMapEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path_prefix = 1; */
        if (message.pathPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pathPrefix);
        /* string package_name = 2; */
        if (message.packageName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.packageName);
        /* string ingress_name = 3; */
        if (message.ingressName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ingressName);
        /* string kind = 4; */
        if (message.kind !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Server.URLMapEntry
 */
export const Server_URLMapEntry = new Server_URLMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Allocation$Type extends MessageType<Allocation> {
    constructor() {
        super("foundation.schema.Allocation", [
            { no: 1, name: "instance", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Allocation_Instance }
        ]);
    }
    create(value?: PartialMessage<Allocation>): Allocation {
        const message = { instance: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Allocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Allocation): Allocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.Allocation.Instance instance */ 1:
                    message.instance.push(Allocation_Instance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Allocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.Allocation.Instance instance = 1; */
        for (let i = 0; i < message.instance.length; i++)
            Allocation_Instance.internalBinaryWrite(message.instance[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Allocation
 */
export const Allocation = new Allocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Allocation_Instance$Type extends MessageType<Allocation_Instance> {
    constructor() {
        super("foundation.schema.Allocation.Instance", [
            { no: 1, name: "instance_owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "alloc_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "instantiated", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Instantiate },
            { no: 5, name: "downstream_allocation", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Allocation }
        ]);
    }
    create(value?: PartialMessage<Allocation_Instance>): Allocation_Instance {
        const message = { instanceOwner: "", packageName: "", allocName: "", instantiated: [], downstreamAllocation: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Allocation_Instance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Allocation_Instance): Allocation_Instance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string instance_owner */ 1:
                    message.instanceOwner = reader.string();
                    break;
                case /* string package_name */ 2:
                    message.packageName = reader.string();
                    break;
                case /* string alloc_name */ 3:
                    message.allocName = reader.string();
                    break;
                case /* repeated foundation.schema.Instantiate instantiated */ 4:
                    message.instantiated.push(Instantiate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Allocation downstream_allocation */ 5:
                    message.downstreamAllocation.push(Allocation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Allocation_Instance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string instance_owner = 1; */
        if (message.instanceOwner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instanceOwner);
        /* string package_name = 2; */
        if (message.packageName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.packageName);
        /* string alloc_name = 3; */
        if (message.allocName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.allocName);
        /* repeated foundation.schema.Instantiate instantiated = 4; */
        for (let i = 0; i < message.instantiated.length; i++)
            Instantiate.internalBinaryWrite(message.instantiated[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Allocation downstream_allocation = 5; */
        for (let i = 0; i < message.downstreamAllocation.length; i++)
            Allocation.internalBinaryWrite(message.downstreamAllocation[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Allocation.Instance
 */
export const Allocation_Instance = new Allocation_Instance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instantiate$Type extends MessageType<Instantiate> {
    constructor() {
        super("foundation.schema.Instantiate", [
            { no: 3, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "constructor", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<Instantiate>): Instantiate {
        const message = { packageName: "", type: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Instantiate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instantiate): Instantiate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string package_name */ 3:
                    message.packageName = reader.string();
                    break;
                case /* string type */ 4:
                    message.type = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any constructor */ 2:
                    message.constructor = Any.internalBinaryRead(reader, reader.uint32(), options, message.constructor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Instantiate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string package_name = 3; */
        if (message.packageName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.packageName);
        /* string type = 4; */
        if (message.type !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any constructor = 2; */
        if (message.constructor)
            Any.internalBinaryWrite(message.constructor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Instantiate
 */
export const Instantiate = new Instantiate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Environment$Type extends MessageType<Environment> {
    constructor() {
        super("foundation.schema.Environment", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "purpose", kind: "enum", T: () => ["foundation.schema.Environment.Purpose", Environment_Purpose] },
            { no: 4, name: "ephemeral", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Environment>): Environment {
        const message = { name: "", runtime: "", purpose: 0, ephemeral: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Environment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Environment): Environment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string runtime */ 2:
                    message.runtime = reader.string();
                    break;
                case /* foundation.schema.Environment.Purpose purpose */ 3:
                    message.purpose = reader.int32();
                    break;
                case /* bool ephemeral */ 4:
                    message.ephemeral = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Environment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string runtime = 2; */
        if (message.runtime !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtime);
        /* foundation.schema.Environment.Purpose purpose = 3; */
        if (message.purpose !== 0)
            writer.tag(3, WireType.Varint).int32(message.purpose);
        /* bool ephemeral = 4; */
        if (message.ephemeral !== false)
            writer.tag(4, WireType.Varint).bool(message.ephemeral);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Environment
 */
export const Environment = new Environment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Platform$Type extends MessageType<Platform> {
    constructor() {
        super("foundation.schema.Platform", [
            { no: 1, name: "architecture", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "os", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "variant", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Platform>): Platform {
        const message = { architecture: "", os: "", variant: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Platform>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Platform): Platform {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string architecture */ 1:
                    message.architecture = reader.string();
                    break;
                case /* string os */ 2:
                    message.os = reader.string();
                    break;
                case /* string variant */ 3:
                    message.variant = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Platform, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string architecture = 1; */
        if (message.architecture !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.architecture);
        /* string os = 2; */
        if (message.os !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.os);
        /* string variant = 3; */
        if (message.variant !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.variant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Platform
 */
export const Platform = new Platform$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpExportedService$Type extends MessageType<HttpExportedService> {
    constructor() {
        super("foundation.schema.HttpExportedService", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HttpExportedService>): HttpExportedService {
        const message = { path: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HttpExportedService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpExportedService): HttpExportedService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpExportedService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.HttpExportedService
 */
export const HttpExportedService = new HttpExportedService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequiredStorage$Type extends MessageType<RequiredStorage> {
    constructor() {
        super("foundation.schema.RequiredStorage", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "persistent_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "byte_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "mount_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequiredStorage>): RequiredStorage {
        const message = { owner: "", persistentId: "", byteCount: 0n, mountPath: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequiredStorage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequiredStorage): RequiredStorage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* string persistent_id */ 2:
                    message.persistentId = reader.string();
                    break;
                case /* uint64 byte_count */ 3:
                    message.byteCount = reader.uint64().toBigInt();
                    break;
                case /* string mount_path */ 4:
                    message.mountPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequiredStorage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* string persistent_id = 2; */
        if (message.persistentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.persistentId);
        /* uint64 byte_count = 3; */
        if (message.byteCount !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.byteCount);
        /* string mount_path = 4; */
        if (message.mountPath !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.mountPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.RequiredStorage
 */
export const RequiredStorage = new RequiredStorage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Naming$Type extends MessageType<Naming> {
    constructor() {
        super("foundation.schema.Naming", [
            { no: 1, name: "with_org", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "additional_user_specified", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Naming_AdditionalDomainName },
            { no: 3, name: "additional_tls_managed", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Naming_AdditionalDomainName }
        ]);
    }
    create(value?: PartialMessage<Naming>): Naming {
        const message = { withOrg: "", additionalUserSpecified: [], additionalTlsManaged: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Naming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Naming): Naming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string with_org */ 1:
                    message.withOrg = reader.string();
                    break;
                case /* repeated foundation.schema.Naming.AdditionalDomainName additional_user_specified */ 2:
                    message.additionalUserSpecified.push(Naming_AdditionalDomainName.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Naming.AdditionalDomainName additional_tls_managed */ 3:
                    message.additionalTlsManaged.push(Naming_AdditionalDomainName.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Naming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string with_org = 1; */
        if (message.withOrg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.withOrg);
        /* repeated foundation.schema.Naming.AdditionalDomainName additional_user_specified = 2; */
        for (let i = 0; i < message.additionalUserSpecified.length; i++)
            Naming_AdditionalDomainName.internalBinaryWrite(message.additionalUserSpecified[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Naming.AdditionalDomainName additional_tls_managed = 3; */
        for (let i = 0; i < message.additionalTlsManaged.length; i++)
            Naming_AdditionalDomainName.internalBinaryWrite(message.additionalTlsManaged[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Naming
 */
export const Naming = new Naming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Naming_AdditionalDomainName$Type extends MessageType<Naming_AdditionalDomainName> {
    constructor() {
        super("foundation.schema.Naming.AdditionalDomainName", [
            { no: 1, name: "allocated_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fqdn", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Naming_AdditionalDomainName>): Naming_AdditionalDomainName {
        const message = { allocatedName: "", fqdn: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Naming_AdditionalDomainName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Naming_AdditionalDomainName): Naming_AdditionalDomainName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string allocated_name */ 1:
                    message.allocatedName = reader.string();
                    break;
                case /* string fqdn */ 2:
                    message.fqdn = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Naming_AdditionalDomainName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string allocated_name = 1; */
        if (message.allocatedName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.allocatedName);
        /* string fqdn = 2; */
        if (message.fqdn !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fqdn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Naming.AdditionalDomainName
 */
export const Naming_AdditionalDomainName = new Naming_AdditionalDomainName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComputedNaming$Type extends MessageType<ComputedNaming> {
    constructor() {
        super("foundation.schema.ComputedNaming", [
            { no: 1, name: "source", kind: "message", T: () => Naming },
            { no: 2, name: "base_domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "managed", kind: "enum", T: () => ["foundation.schema.Domain.ManagedType", Domain_ManagedType] }
        ]);
    }
    create(value?: PartialMessage<ComputedNaming>): ComputedNaming {
        const message = { baseDomain: "", managed: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ComputedNaming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComputedNaming): ComputedNaming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* foundation.schema.Naming source */ 1:
                    message.source = Naming.internalBinaryRead(reader, reader.uint32(), options, message.source);
                    break;
                case /* string base_domain */ 2:
                    message.baseDomain = reader.string();
                    break;
                case /* foundation.schema.Domain.ManagedType managed */ 3:
                    message.managed = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComputedNaming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* foundation.schema.Naming source = 1; */
        if (message.source)
            Naming.internalBinaryWrite(message.source, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string base_domain = 2; */
        if (message.baseDomain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.baseDomain);
        /* foundation.schema.Domain.ManagedType managed = 3; */
        if (message.managed !== 0)
            writer.tag(3, WireType.Varint).int32(message.managed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.ComputedNaming
 */
export const ComputedNaming = new ComputedNaming$Type();
