// @generated by protobuf-ts 2.7.0 with parameter force_disable_services,add_pb_suffix,force_exclude_all_options
// @generated from protobuf file "schema/binary.proto" (package "foundation.schema", syntax proto3)
// tslint:disable
//
// Copyright 2022 Namespace Labs Inc; All rights reserved.
// Licensed under the EARLY ACCESS SOFTWARE LICENSE AGREEMENT
// available at http://github.com/namespacelabs/foundation
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * A "binary" represents a compiled image. It's similar to a Docker image,
 * with the difference that the mechanism to build a binary is always
 * attached to itself -- i.e. it's a reproducible build.
 *
 * @generated from protobuf message foundation.schema.Binary
 */
export interface Binary {
    /**
     * The package name (computed).
     *
     * @generated from protobuf field: string package_name = 1;
     */
    packageName: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: foundation.schema.BinaryConfig config = 6;
     */
    config?: BinaryConfig; // Run instructions.
    /**
     * @generated from protobuf field: foundation.schema.ImageBuildPlan from = 7;
     */
    from?: ImageBuildPlan; // XXX Deprecated, use build_plan.
    /**
     * @generated from protobuf field: foundation.schema.LayeredImageBuildPlan build_plan = 8;
     */
    buildPlan?: LayeredImageBuildPlan;
}
/**
 * @generated from protobuf message foundation.schema.ImageBuildPlan
 */
export interface ImageBuildPlan {
    /**
     * @generated from protobuf field: string go_package = 1;
     */
    goPackage: string; // Use go binary builder.
    /**
     * @generated from protobuf field: string dockerfile = 2;
     */
    dockerfile: string; // Use Dockerfile builder.
    /**
     * @generated from protobuf field: string web_build = 3;
     */
    webBuild: string; // Use Web build (temporary).
    /**
     * @generated from protobuf field: foundation.schema.ImageBuildPlan.LLBPlan llb_plan = 4;
     */
    llbPlan?: ImageBuildPlan_LLBPlan; // Build  binary which itself produces LLB.
    /**
     * @generated from protobuf field: string nix_flake = 5;
     */
    nixFlake: string; // Build a docker image from a nix flake.
    /**
     * @generated from protobuf field: repeated string snapshot_files = 6;
     */
    snapshotFiles: string[]; // Add all referenced files, and directories, recursively visiting their children.
}
/**
 * @generated from protobuf message foundation.schema.ImageBuildPlan.LLBPlan
 */
export interface ImageBuildPlan_LLBPlan {
    /**
     * @generated from protobuf field: foundation.schema.Binary output_of = 1;
     */
    outputOf?: Binary;
}
/**
 * @generated from protobuf message foundation.schema.LayeredImageBuildPlan
 */
export interface LayeredImageBuildPlan {
    /**
     * @generated from protobuf field: repeated foundation.schema.ImageBuildPlan layer_build_plan = 1;
     */
    layerBuildPlan: ImageBuildPlan[]; // Each build plan will yield N layers, in order.
}
/**
 * Instructions of how to invoke the image, if it includes an invocable binary.
 *
 * @generated from protobuf message foundation.schema.BinaryConfig
 */
export interface BinaryConfig {
    /**
     * @generated from protobuf field: repeated string command = 1;
     */
    command: string[];
    /**
     * @generated from protobuf field: repeated string args = 2;
     */
    args: string[];
    /**
     * @generated from protobuf field: repeated foundation.schema.BinaryConfig.EnvEntry env = 3;
     */
    env: BinaryConfig_EnvEntry[];
}
/**
 * @generated from protobuf message foundation.schema.BinaryConfig.EnvEntry
 */
export interface BinaryConfig_EnvEntry {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
    /**
     * @generated from protobuf field: string experimental_from_secret = 3;
     */
    experimentalFromSecret: string; // Runtime specific.
}
// @generated message type with reflection information, may provide speed optimized methods
class Binary$Type extends MessageType<Binary> {
    constructor() {
        super("foundation.schema.Binary", [
            { no: 1, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "config", kind: "message", T: () => BinaryConfig },
            { no: 7, name: "from", kind: "message", T: () => ImageBuildPlan },
            { no: 8, name: "build_plan", kind: "message", T: () => LayeredImageBuildPlan }
        ]);
    }
    create(value?: PartialMessage<Binary>): Binary {
        const message = { packageName: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Binary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Binary): Binary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string package_name */ 1:
                    message.packageName = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* foundation.schema.BinaryConfig config */ 6:
                    message.config = BinaryConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* foundation.schema.ImageBuildPlan from */ 7:
                    message.from = ImageBuildPlan.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* foundation.schema.LayeredImageBuildPlan build_plan */ 8:
                    message.buildPlan = LayeredImageBuildPlan.internalBinaryRead(reader, reader.uint32(), options, message.buildPlan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Binary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string package_name = 1; */
        if (message.packageName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.packageName);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* foundation.schema.BinaryConfig config = 6; */
        if (message.config)
            BinaryConfig.internalBinaryWrite(message.config, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.ImageBuildPlan from = 7; */
        if (message.from)
            ImageBuildPlan.internalBinaryWrite(message.from, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.LayeredImageBuildPlan build_plan = 8; */
        if (message.buildPlan)
            LayeredImageBuildPlan.internalBinaryWrite(message.buildPlan, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Binary
 */
export const Binary = new Binary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageBuildPlan$Type extends MessageType<ImageBuildPlan> {
    constructor() {
        super("foundation.schema.ImageBuildPlan", [
            { no: 1, name: "go_package", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dockerfile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "web_build", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "llb_plan", kind: "message", T: () => ImageBuildPlan_LLBPlan },
            { no: 5, name: "nix_flake", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "snapshot_files", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImageBuildPlan>): ImageBuildPlan {
        const message = { goPackage: "", dockerfile: "", webBuild: "", nixFlake: "", snapshotFiles: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImageBuildPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageBuildPlan): ImageBuildPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string go_package */ 1:
                    message.goPackage = reader.string();
                    break;
                case /* string dockerfile */ 2:
                    message.dockerfile = reader.string();
                    break;
                case /* string web_build */ 3:
                    message.webBuild = reader.string();
                    break;
                case /* foundation.schema.ImageBuildPlan.LLBPlan llb_plan */ 4:
                    message.llbPlan = ImageBuildPlan_LLBPlan.internalBinaryRead(reader, reader.uint32(), options, message.llbPlan);
                    break;
                case /* string nix_flake */ 5:
                    message.nixFlake = reader.string();
                    break;
                case /* repeated string snapshot_files */ 6:
                    message.snapshotFiles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageBuildPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string go_package = 1; */
        if (message.goPackage !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.goPackage);
        /* string dockerfile = 2; */
        if (message.dockerfile !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dockerfile);
        /* string web_build = 3; */
        if (message.webBuild !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.webBuild);
        /* foundation.schema.ImageBuildPlan.LLBPlan llb_plan = 4; */
        if (message.llbPlan)
            ImageBuildPlan_LLBPlan.internalBinaryWrite(message.llbPlan, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string nix_flake = 5; */
        if (message.nixFlake !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nixFlake);
        /* repeated string snapshot_files = 6; */
        for (let i = 0; i < message.snapshotFiles.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.snapshotFiles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.ImageBuildPlan
 */
export const ImageBuildPlan = new ImageBuildPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageBuildPlan_LLBPlan$Type extends MessageType<ImageBuildPlan_LLBPlan> {
    constructor() {
        super("foundation.schema.ImageBuildPlan.LLBPlan", [
            { no: 1, name: "output_of", kind: "message", T: () => Binary }
        ]);
    }
    create(value?: PartialMessage<ImageBuildPlan_LLBPlan>): ImageBuildPlan_LLBPlan {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ImageBuildPlan_LLBPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageBuildPlan_LLBPlan): ImageBuildPlan_LLBPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* foundation.schema.Binary output_of */ 1:
                    message.outputOf = Binary.internalBinaryRead(reader, reader.uint32(), options, message.outputOf);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageBuildPlan_LLBPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* foundation.schema.Binary output_of = 1; */
        if (message.outputOf)
            Binary.internalBinaryWrite(message.outputOf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.ImageBuildPlan.LLBPlan
 */
export const ImageBuildPlan_LLBPlan = new ImageBuildPlan_LLBPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayeredImageBuildPlan$Type extends MessageType<LayeredImageBuildPlan> {
    constructor() {
        super("foundation.schema.LayeredImageBuildPlan", [
            { no: 1, name: "layer_build_plan", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ImageBuildPlan }
        ]);
    }
    create(value?: PartialMessage<LayeredImageBuildPlan>): LayeredImageBuildPlan {
        const message = { layerBuildPlan: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayeredImageBuildPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayeredImageBuildPlan): LayeredImageBuildPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.ImageBuildPlan layer_build_plan */ 1:
                    message.layerBuildPlan.push(ImageBuildPlan.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayeredImageBuildPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.ImageBuildPlan layer_build_plan = 1; */
        for (let i = 0; i < message.layerBuildPlan.length; i++)
            ImageBuildPlan.internalBinaryWrite(message.layerBuildPlan[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.LayeredImageBuildPlan
 */
export const LayeredImageBuildPlan = new LayeredImageBuildPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryConfig$Type extends MessageType<BinaryConfig> {
    constructor() {
        super("foundation.schema.BinaryConfig", [
            { no: 1, name: "command", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "args", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "env", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BinaryConfig_EnvEntry }
        ]);
    }
    create(value?: PartialMessage<BinaryConfig>): BinaryConfig {
        const message = { command: [], args: [], env: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BinaryConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryConfig): BinaryConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string command */ 1:
                    message.command.push(reader.string());
                    break;
                case /* repeated string args */ 2:
                    message.args.push(reader.string());
                    break;
                case /* repeated foundation.schema.BinaryConfig.EnvEntry env */ 3:
                    message.env.push(BinaryConfig_EnvEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string command = 1; */
        for (let i = 0; i < message.command.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.command[i]);
        /* repeated string args = 2; */
        for (let i = 0; i < message.args.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.args[i]);
        /* repeated foundation.schema.BinaryConfig.EnvEntry env = 3; */
        for (let i = 0; i < message.env.length; i++)
            BinaryConfig_EnvEntry.internalBinaryWrite(message.env[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.BinaryConfig
 */
export const BinaryConfig = new BinaryConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryConfig_EnvEntry$Type extends MessageType<BinaryConfig_EnvEntry> {
    constructor() {
        super("foundation.schema.BinaryConfig.EnvEntry", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "experimental_from_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BinaryConfig_EnvEntry>): BinaryConfig_EnvEntry {
        const message = { name: "", value: "", experimentalFromSecret: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BinaryConfig_EnvEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryConfig_EnvEntry): BinaryConfig_EnvEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* string experimental_from_secret */ 3:
                    message.experimentalFromSecret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryConfig_EnvEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* string experimental_from_secret = 3; */
        if (message.experimentalFromSecret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.experimentalFromSecret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.BinaryConfig.EnvEntry
 */
export const BinaryConfig_EnvEntry = new BinaryConfig_EnvEntry$Type();
