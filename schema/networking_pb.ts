// @generated by protobuf-ts 2.7.0 with parameter force_disable_services,add_pb_suffix,force_exclude_all_options
// @generated from protobuf file "schema/networking.proto" (package "foundation.schema", syntax proto3)
// tslint:disable
//
// Copyright 2022 Namespace Labs Inc; All rights reserved.
// Licensed under the EARLY ACCESS SOFTWARE LICENSE AGREEMENT
// available at http://github.com/namespacelabs/foundation
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FileDescriptorSet } from "../google/protobuf/descriptor_pb";
import { Any } from "../google/protobuf/any_pb";
/**
 * @generated from protobuf message foundation.schema.Endpoint
 */
export interface Endpoint {
    /**
     * @generated from protobuf field: foundation.schema.Endpoint.Type type = 1;
     */
    type: Endpoint_Type;
    /**
     * The tuple (endpoint_owner, service_name) uniquely identifies an endpoint.
     *
     * @generated from protobuf field: string service_name = 3;
     */
    serviceName: string;
    /**
     * @generated from protobuf field: string endpoint_owner = 4;
     */
    endpointOwner: string; // Package name.
    /**
     * @generated from protobuf field: foundation.schema.Endpoint.Port port = 5;
     */
    port?: Endpoint_Port;
    /**
     * @generated from protobuf field: string allocated_name = 6;
     */
    allocatedName: string;
    /**
     * @generated from protobuf field: string server_owner = 7;
     */
    serverOwner: string; // Package name.
    /**
     * @generated from protobuf field: repeated foundation.schema.ServiceMetadata service_metadata = 8;
     */
    serviceMetadata: ServiceMetadata[];
    /**
     * @generated from protobuf field: repeated foundation.schema.Endpoint.IngressHttpPath http_path = 9;
     */
    httpPath: Endpoint_IngressHttpPath[]; // Only valid if type=INTERNET_FACING.
}
/**
 * @generated from protobuf message foundation.schema.Endpoint.Port
 */
export interface Endpoint_Port {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 container_port = 2;
     */
    containerPort: number;
}
/**
 * @generated from protobuf message foundation.schema.Endpoint.IngressHttpPath
 */
export interface Endpoint_IngressHttpPath {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: string owner = 3;
     */
    owner: string; // Package name.
    /**
     * @generated from protobuf field: string service = 4;
     */
    service: string;
    /**
     * @generated from protobuf field: foundation.schema.Endpoint.Port port = 5;
     */
    port?: Endpoint_Port;
}
/**
 * @generated from protobuf enum foundation.schema.Endpoint.Type
 */
export enum Endpoint_Type {
    /**
     * Defaults to PRIVATE in services.
     *
     * @generated from protobuf enum value: INGRESS_UNSPECIFIED = 0;
     */
    INGRESS_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PRIVATE = 1;
     */
    PRIVATE = 1,
    /**
     * @generated from protobuf enum value: INTERNET_FACING = 2;
     */
    INTERNET_FACING = 2
}
/**
 * @generated from protobuf message foundation.schema.InternalEndpoint
 */
export interface InternalEndpoint {
    /**
     * @generated from protobuf field: string server_owner = 1;
     */
    serverOwner: string; // Package name.
    /**
     * @generated from protobuf field: foundation.schema.Endpoint.Port port = 2;
     */
    port?: Endpoint_Port;
    /**
     * @generated from protobuf field: repeated foundation.schema.ServiceMetadata service_metadata = 3;
     */
    serviceMetadata: ServiceMetadata[];
}
/**
 * @generated from protobuf message foundation.schema.IngressFragment
 */
export interface IngressFragment {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string owner = 2;
     */
    owner: string; // Server package name.
    /**
     * @generated from protobuf field: foundation.schema.Domain domain = 3;
     */
    domain?: Domain;
    /**
     * @generated from protobuf field: foundation.schema.Endpoint endpoint = 6;
     */
    endpoint?: Endpoint;
    /**
     * @generated from protobuf field: repeated foundation.schema.IngressFragment.IngressHttpPath http_path = 4;
     */
    httpPath: IngressFragment_IngressHttpPath[];
    /**
     * @generated from protobuf field: repeated foundation.schema.IngressFragment.IngressGrpcService grpc_service = 7;
     */
    grpcService: IngressFragment_IngressGrpcService[];
    /**
     * @generated from protobuf field: string manager = 8;
     */
    manager: string; // If this is a specialized ingress, it may be annotated as such. E.g. with namespacelabs.dev/foundation/std/grp/httptranscoding.
    /**
     * Accepted: HttpCors.
     *
     * @generated from protobuf field: repeated google.protobuf.Any extension = 5;
     */
    extension: Any[];
}
/**
 * @generated from protobuf message foundation.schema.IngressFragment.IngressHttpPath
 */
export interface IngressFragment_IngressHttpPath {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
    /**
     * @generated from protobuf field: string owner = 3;
     */
    owner: string; // Package name.
    /**
     * @generated from protobuf field: string service = 4;
     */
    service: string; // Backend service.
    /**
     * @generated from protobuf field: foundation.schema.Endpoint.Port port = 5;
     */
    port?: Endpoint_Port;
}
/**
 * @generated from protobuf message foundation.schema.IngressFragment.IngressGrpcService
 */
export interface IngressFragment_IngressGrpcService {
    /**
     * @generated from protobuf field: string grpc_service = 1;
     */
    grpcService: string; // Fully qualified name.
    /**
     * @generated from protobuf field: string owner = 2;
     */
    owner: string; // Package name.
    /**
     * @generated from protobuf field: string service = 3;
     */
    service: string; // Backing service.
    /**
     * @generated from protobuf field: repeated string method = 5;
     */
    method: string[]; // If not set, forward all methods.
    /**
     * @generated from protobuf field: foundation.schema.Endpoint.Port port = 4;
     */
    port?: Endpoint_Port;
}
/**
 * @generated from protobuf message foundation.schema.IngressFragmentList
 */
export interface IngressFragmentList {
    /**
     * @generated from protobuf field: repeated foundation.schema.IngressFragment ingress_fragment = 1;
     */
    ingressFragment: IngressFragment[];
}
/**
 * @generated from protobuf message foundation.schema.HttpCors
 */
export interface HttpCors {
    /**
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: repeated string allowed_origin = 2;
     */
    allowedOrigin: string[];
}
/**
 * @generated from protobuf message foundation.schema.Domain
 */
export interface Domain {
    /**
     * @generated from protobuf field: string fqdn = 1;
     */
    fqdn: string;
    /**
     * @generated from protobuf field: foundation.schema.Domain.Certificate certificate = 2;
     */
    certificate?: Domain_Certificate;
    /**
     * @generated from protobuf field: foundation.schema.Domain.ManagedType managed = 3;
     */
    managed: Domain_ManagedType;
}
/**
 * @generated from protobuf message foundation.schema.Domain.Certificate
 */
export interface Domain_Certificate {
    /**
     * @generated from protobuf field: bytes private_key = 1;
     */
    privateKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes certificate_bundle = 2;
     */
    certificateBundle: Uint8Array;
}
/**
 * @generated from protobuf enum foundation.schema.Domain.ManagedType
 */
export enum Domain_ManagedType {
    /**
     * @generated from protobuf enum value: MANAGED_UNKNOWN = 0;
     */
    MANAGED_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: LOCAL_MANAGED = 1;
     */
    LOCAL_MANAGED = 1,
    /**
     * @generated from protobuf enum value: CLOUD_MANAGED = 2;
     */
    CLOUD_MANAGED = 2,
    /**
     * @generated from protobuf enum value: USER_SPECIFIED = 3;
     */
    USER_SPECIFIED = 3,
    /**
     * @generated from protobuf enum value: USER_SPECIFIED_TLS_MANAGED = 4;
     */
    USER_SPECIFIED_TLS_MANAGED = 4
}
/**
 * @generated from protobuf message foundation.schema.ServiceMetadata
 */
export interface ServiceMetadata {
    /**
     * @generated from protobuf field: string kind = 1;
     */
    kind: string;
    /**
     * @generated from protobuf field: string protocol = 2;
     */
    protocol: string;
    /**
     * @generated from protobuf field: google.protobuf.Any details = 3;
     */
    details?: Any;
}
/**
 * @generated from protobuf message foundation.schema.HttpUrlMap
 */
export interface HttpUrlMap {
    /**
     * @generated from protobuf field: repeated foundation.schema.HttpUrlMap.Entry entry = 1;
     */
    entry: HttpUrlMap_Entry[];
}
/**
 * @generated from protobuf message foundation.schema.HttpUrlMap.Entry
 */
export interface HttpUrlMap_Entry {
    /**
     * @generated from protobuf field: string path_prefix = 1;
     */
    pathPrefix: string;
    /**
     * @generated from protobuf field: string kind = 2;
     */
    kind: string;
}
/**
 * @generated from protobuf message foundation.schema.GrpcHttpTranscoding
 */
export interface GrpcHttpTranscoding {
    /**
     * Includes the service proto definition, and its dependencies.
     *
     * @generated from protobuf field: google.protobuf.FileDescriptorSet file_descriptor_set = 1;
     */
    fileDescriptorSet?: FileDescriptorSet;
}
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint$Type extends MessageType<Endpoint> {
    constructor() {
        super("foundation.schema.Endpoint", [
            { no: 1, name: "type", kind: "enum", T: () => ["foundation.schema.Endpoint.Type", Endpoint_Type] },
            { no: 3, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "endpoint_owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "port", kind: "message", T: () => Endpoint_Port },
            { no: 6, name: "allocated_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "server_owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "service_metadata", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceMetadata },
            { no: 9, name: "http_path", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint_IngressHttpPath }
        ]);
    }
    create(value?: PartialMessage<Endpoint>): Endpoint {
        const message = { type: 0, serviceName: "", endpointOwner: "", allocatedName: "", serverOwner: "", serviceMetadata: [], httpPath: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Endpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint): Endpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* foundation.schema.Endpoint.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string service_name */ 3:
                    message.serviceName = reader.string();
                    break;
                case /* string endpoint_owner */ 4:
                    message.endpointOwner = reader.string();
                    break;
                case /* foundation.schema.Endpoint.Port port */ 5:
                    message.port = Endpoint_Port.internalBinaryRead(reader, reader.uint32(), options, message.port);
                    break;
                case /* string allocated_name */ 6:
                    message.allocatedName = reader.string();
                    break;
                case /* string server_owner */ 7:
                    message.serverOwner = reader.string();
                    break;
                case /* repeated foundation.schema.ServiceMetadata service_metadata */ 8:
                    message.serviceMetadata.push(ServiceMetadata.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.Endpoint.IngressHttpPath http_path */ 9:
                    message.httpPath.push(Endpoint_IngressHttpPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* foundation.schema.Endpoint.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string service_name = 3; */
        if (message.serviceName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serviceName);
        /* string endpoint_owner = 4; */
        if (message.endpointOwner !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endpointOwner);
        /* foundation.schema.Endpoint.Port port = 5; */
        if (message.port)
            Endpoint_Port.internalBinaryWrite(message.port, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string allocated_name = 6; */
        if (message.allocatedName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.allocatedName);
        /* string server_owner = 7; */
        if (message.serverOwner !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.serverOwner);
        /* repeated foundation.schema.ServiceMetadata service_metadata = 8; */
        for (let i = 0; i < message.serviceMetadata.length; i++)
            ServiceMetadata.internalBinaryWrite(message.serviceMetadata[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.Endpoint.IngressHttpPath http_path = 9; */
        for (let i = 0; i < message.httpPath.length; i++)
            Endpoint_IngressHttpPath.internalBinaryWrite(message.httpPath[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Endpoint
 */
export const Endpoint = new Endpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint_Port$Type extends MessageType<Endpoint_Port> {
    constructor() {
        super("foundation.schema.Endpoint.Port", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "container_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Endpoint_Port>): Endpoint_Port {
        const message = { name: "", containerPort: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Endpoint_Port>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint_Port): Endpoint_Port {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 container_port */ 2:
                    message.containerPort = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint_Port, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 container_port = 2; */
        if (message.containerPort !== 0)
            writer.tag(2, WireType.Varint).int32(message.containerPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Endpoint.Port
 */
export const Endpoint_Port = new Endpoint_Port$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint_IngressHttpPath$Type extends MessageType<Endpoint_IngressHttpPath> {
    constructor() {
        super("foundation.schema.Endpoint.IngressHttpPath", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "port", kind: "message", T: () => Endpoint_Port }
        ]);
    }
    create(value?: PartialMessage<Endpoint_IngressHttpPath>): Endpoint_IngressHttpPath {
        const message = { path: "", kind: "", owner: "", service: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Endpoint_IngressHttpPath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint_IngressHttpPath): Endpoint_IngressHttpPath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* string owner */ 3:
                    message.owner = reader.string();
                    break;
                case /* string service */ 4:
                    message.service = reader.string();
                    break;
                case /* foundation.schema.Endpoint.Port port */ 5:
                    message.port = Endpoint_Port.internalBinaryRead(reader, reader.uint32(), options, message.port);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint_IngressHttpPath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string owner = 3; */
        if (message.owner !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.owner);
        /* string service = 4; */
        if (message.service !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.service);
        /* foundation.schema.Endpoint.Port port = 5; */
        if (message.port)
            Endpoint_Port.internalBinaryWrite(message.port, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Endpoint.IngressHttpPath
 */
export const Endpoint_IngressHttpPath = new Endpoint_IngressHttpPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InternalEndpoint$Type extends MessageType<InternalEndpoint> {
    constructor() {
        super("foundation.schema.InternalEndpoint", [
            { no: 1, name: "server_owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "message", T: () => Endpoint_Port },
            { no: 3, name: "service_metadata", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ServiceMetadata }
        ]);
    }
    create(value?: PartialMessage<InternalEndpoint>): InternalEndpoint {
        const message = { serverOwner: "", serviceMetadata: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InternalEndpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InternalEndpoint): InternalEndpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string server_owner */ 1:
                    message.serverOwner = reader.string();
                    break;
                case /* foundation.schema.Endpoint.Port port */ 2:
                    message.port = Endpoint_Port.internalBinaryRead(reader, reader.uint32(), options, message.port);
                    break;
                case /* repeated foundation.schema.ServiceMetadata service_metadata */ 3:
                    message.serviceMetadata.push(ServiceMetadata.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InternalEndpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string server_owner = 1; */
        if (message.serverOwner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverOwner);
        /* foundation.schema.Endpoint.Port port = 2; */
        if (message.port)
            Endpoint_Port.internalBinaryWrite(message.port, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.ServiceMetadata service_metadata = 3; */
        for (let i = 0; i < message.serviceMetadata.length; i++)
            ServiceMetadata.internalBinaryWrite(message.serviceMetadata[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.InternalEndpoint
 */
export const InternalEndpoint = new InternalEndpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IngressFragment$Type extends MessageType<IngressFragment> {
    constructor() {
        super("foundation.schema.IngressFragment", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "domain", kind: "message", T: () => Domain },
            { no: 6, name: "endpoint", kind: "message", T: () => Endpoint },
            { no: 4, name: "http_path", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IngressFragment_IngressHttpPath },
            { no: 7, name: "grpc_service", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IngressFragment_IngressGrpcService },
            { no: 8, name: "manager", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "extension", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any }
        ]);
    }
    create(value?: PartialMessage<IngressFragment>): IngressFragment {
        const message = { name: "", owner: "", httpPath: [], grpcService: [], manager: "", extension: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IngressFragment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IngressFragment): IngressFragment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string owner */ 2:
                    message.owner = reader.string();
                    break;
                case /* foundation.schema.Domain domain */ 3:
                    message.domain = Domain.internalBinaryRead(reader, reader.uint32(), options, message.domain);
                    break;
                case /* foundation.schema.Endpoint endpoint */ 6:
                    message.endpoint = Endpoint.internalBinaryRead(reader, reader.uint32(), options, message.endpoint);
                    break;
                case /* repeated foundation.schema.IngressFragment.IngressHttpPath http_path */ 4:
                    message.httpPath.push(IngressFragment_IngressHttpPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated foundation.schema.IngressFragment.IngressGrpcService grpc_service */ 7:
                    message.grpcService.push(IngressFragment_IngressGrpcService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string manager */ 8:
                    message.manager = reader.string();
                    break;
                case /* repeated google.protobuf.Any extension */ 5:
                    message.extension.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IngressFragment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string owner = 2; */
        if (message.owner !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.owner);
        /* foundation.schema.Domain domain = 3; */
        if (message.domain)
            Domain.internalBinaryWrite(message.domain, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Endpoint endpoint = 6; */
        if (message.endpoint)
            Endpoint.internalBinaryWrite(message.endpoint, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.IngressFragment.IngressHttpPath http_path = 4; */
        for (let i = 0; i < message.httpPath.length; i++)
            IngressFragment_IngressHttpPath.internalBinaryWrite(message.httpPath[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated foundation.schema.IngressFragment.IngressGrpcService grpc_service = 7; */
        for (let i = 0; i < message.grpcService.length; i++)
            IngressFragment_IngressGrpcService.internalBinaryWrite(message.grpcService[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string manager = 8; */
        if (message.manager !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.manager);
        /* repeated google.protobuf.Any extension = 5; */
        for (let i = 0; i < message.extension.length; i++)
            Any.internalBinaryWrite(message.extension[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.IngressFragment
 */
export const IngressFragment = new IngressFragment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IngressFragment_IngressHttpPath$Type extends MessageType<IngressFragment_IngressHttpPath> {
    constructor() {
        super("foundation.schema.IngressFragment.IngressHttpPath", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "port", kind: "message", T: () => Endpoint_Port }
        ]);
    }
    create(value?: PartialMessage<IngressFragment_IngressHttpPath>): IngressFragment_IngressHttpPath {
        const message = { path: "", kind: "", owner: "", service: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IngressFragment_IngressHttpPath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IngressFragment_IngressHttpPath): IngressFragment_IngressHttpPath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                case /* string owner */ 3:
                    message.owner = reader.string();
                    break;
                case /* string service */ 4:
                    message.service = reader.string();
                    break;
                case /* foundation.schema.Endpoint.Port port */ 5:
                    message.port = Endpoint_Port.internalBinaryRead(reader, reader.uint32(), options, message.port);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IngressFragment_IngressHttpPath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        /* string owner = 3; */
        if (message.owner !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.owner);
        /* string service = 4; */
        if (message.service !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.service);
        /* foundation.schema.Endpoint.Port port = 5; */
        if (message.port)
            Endpoint_Port.internalBinaryWrite(message.port, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.IngressFragment.IngressHttpPath
 */
export const IngressFragment_IngressHttpPath = new IngressFragment_IngressHttpPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IngressFragment_IngressGrpcService$Type extends MessageType<IngressFragment_IngressGrpcService> {
    constructor() {
        super("foundation.schema.IngressFragment.IngressGrpcService", [
            { no: 1, name: "grpc_service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "method", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "port", kind: "message", T: () => Endpoint_Port }
        ]);
    }
    create(value?: PartialMessage<IngressFragment_IngressGrpcService>): IngressFragment_IngressGrpcService {
        const message = { grpcService: "", owner: "", service: "", method: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IngressFragment_IngressGrpcService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IngressFragment_IngressGrpcService): IngressFragment_IngressGrpcService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grpc_service */ 1:
                    message.grpcService = reader.string();
                    break;
                case /* string owner */ 2:
                    message.owner = reader.string();
                    break;
                case /* string service */ 3:
                    message.service = reader.string();
                    break;
                case /* repeated string method */ 5:
                    message.method.push(reader.string());
                    break;
                case /* foundation.schema.Endpoint.Port port */ 4:
                    message.port = Endpoint_Port.internalBinaryRead(reader, reader.uint32(), options, message.port);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IngressFragment_IngressGrpcService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grpc_service = 1; */
        if (message.grpcService !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grpcService);
        /* string owner = 2; */
        if (message.owner !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.owner);
        /* string service = 3; */
        if (message.service !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.service);
        /* repeated string method = 5; */
        for (let i = 0; i < message.method.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.method[i]);
        /* foundation.schema.Endpoint.Port port = 4; */
        if (message.port)
            Endpoint_Port.internalBinaryWrite(message.port, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.IngressFragment.IngressGrpcService
 */
export const IngressFragment_IngressGrpcService = new IngressFragment_IngressGrpcService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IngressFragmentList$Type extends MessageType<IngressFragmentList> {
    constructor() {
        super("foundation.schema.IngressFragmentList", [
            { no: 1, name: "ingress_fragment", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IngressFragment }
        ]);
    }
    create(value?: PartialMessage<IngressFragmentList>): IngressFragmentList {
        const message = { ingressFragment: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IngressFragmentList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IngressFragmentList): IngressFragmentList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.IngressFragment ingress_fragment */ 1:
                    message.ingressFragment.push(IngressFragment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IngressFragmentList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.IngressFragment ingress_fragment = 1; */
        for (let i = 0; i < message.ingressFragment.length; i++)
            IngressFragment.internalBinaryWrite(message.ingressFragment[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.IngressFragmentList
 */
export const IngressFragmentList = new IngressFragmentList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpCors$Type extends MessageType<HttpCors> {
    constructor() {
        super("foundation.schema.HttpCors", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "allowed_origin", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HttpCors>): HttpCors {
        const message = { enabled: false, allowedOrigin: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HttpCors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpCors): HttpCors {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* repeated string allowed_origin */ 2:
                    message.allowedOrigin.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpCors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* repeated string allowed_origin = 2; */
        for (let i = 0; i < message.allowedOrigin.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.allowedOrigin[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.HttpCors
 */
export const HttpCors = new HttpCors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Domain$Type extends MessageType<Domain> {
    constructor() {
        super("foundation.schema.Domain", [
            { no: 1, name: "fqdn", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "certificate", kind: "message", T: () => Domain_Certificate },
            { no: 3, name: "managed", kind: "enum", T: () => ["foundation.schema.Domain.ManagedType", Domain_ManagedType] }
        ]);
    }
    create(value?: PartialMessage<Domain>): Domain {
        const message = { fqdn: "", managed: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Domain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Domain): Domain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fqdn */ 1:
                    message.fqdn = reader.string();
                    break;
                case /* foundation.schema.Domain.Certificate certificate */ 2:
                    message.certificate = Domain_Certificate.internalBinaryRead(reader, reader.uint32(), options, message.certificate);
                    break;
                case /* foundation.schema.Domain.ManagedType managed */ 3:
                    message.managed = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Domain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fqdn = 1; */
        if (message.fqdn !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fqdn);
        /* foundation.schema.Domain.Certificate certificate = 2; */
        if (message.certificate)
            Domain_Certificate.internalBinaryWrite(message.certificate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* foundation.schema.Domain.ManagedType managed = 3; */
        if (message.managed !== 0)
            writer.tag(3, WireType.Varint).int32(message.managed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Domain
 */
export const Domain = new Domain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Domain_Certificate$Type extends MessageType<Domain_Certificate> {
    constructor() {
        super("foundation.schema.Domain.Certificate", [
            { no: 1, name: "private_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "certificate_bundle", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Domain_Certificate>): Domain_Certificate {
        const message = { privateKey: new Uint8Array(0), certificateBundle: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Domain_Certificate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Domain_Certificate): Domain_Certificate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes private_key */ 1:
                    message.privateKey = reader.bytes();
                    break;
                case /* bytes certificate_bundle */ 2:
                    message.certificateBundle = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Domain_Certificate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes private_key = 1; */
        if (message.privateKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.privateKey);
        /* bytes certificate_bundle = 2; */
        if (message.certificateBundle.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.certificateBundle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.Domain.Certificate
 */
export const Domain_Certificate = new Domain_Certificate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceMetadata$Type extends MessageType<ServiceMetadata> {
    constructor() {
        super("foundation.schema.ServiceMetadata", [
            { no: 1, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "protocol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "details", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ServiceMetadata>): ServiceMetadata {
        const message = { kind: "", protocol: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceMetadata): ServiceMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string kind */ 1:
                    message.kind = reader.string();
                    break;
                case /* string protocol */ 2:
                    message.protocol = reader.string();
                    break;
                case /* google.protobuf.Any details */ 3:
                    message.details = Any.internalBinaryRead(reader, reader.uint32(), options, message.details);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string kind = 1; */
        if (message.kind !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.kind);
        /* string protocol = 2; */
        if (message.protocol !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.protocol);
        /* google.protobuf.Any details = 3; */
        if (message.details)
            Any.internalBinaryWrite(message.details, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.ServiceMetadata
 */
export const ServiceMetadata = new ServiceMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpUrlMap$Type extends MessageType<HttpUrlMap> {
    constructor() {
        super("foundation.schema.HttpUrlMap", [
            { no: 1, name: "entry", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpUrlMap_Entry }
        ]);
    }
    create(value?: PartialMessage<HttpUrlMap>): HttpUrlMap {
        const message = { entry: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HttpUrlMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpUrlMap): HttpUrlMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated foundation.schema.HttpUrlMap.Entry entry */ 1:
                    message.entry.push(HttpUrlMap_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpUrlMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated foundation.schema.HttpUrlMap.Entry entry = 1; */
        for (let i = 0; i < message.entry.length; i++)
            HttpUrlMap_Entry.internalBinaryWrite(message.entry[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.HttpUrlMap
 */
export const HttpUrlMap = new HttpUrlMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpUrlMap_Entry$Type extends MessageType<HttpUrlMap_Entry> {
    constructor() {
        super("foundation.schema.HttpUrlMap.Entry", [
            { no: 1, name: "path_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HttpUrlMap_Entry>): HttpUrlMap_Entry {
        const message = { pathPrefix: "", kind: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HttpUrlMap_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpUrlMap_Entry): HttpUrlMap_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path_prefix */ 1:
                    message.pathPrefix = reader.string();
                    break;
                case /* string kind */ 2:
                    message.kind = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpUrlMap_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path_prefix = 1; */
        if (message.pathPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pathPrefix);
        /* string kind = 2; */
        if (message.kind !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.HttpUrlMap.Entry
 */
export const HttpUrlMap_Entry = new HttpUrlMap_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrpcHttpTranscoding$Type extends MessageType<GrpcHttpTranscoding> {
    constructor() {
        super("foundation.schema.GrpcHttpTranscoding", [
            { no: 1, name: "file_descriptor_set", kind: "message", T: () => FileDescriptorSet }
        ]);
    }
    create(value?: PartialMessage<GrpcHttpTranscoding>): GrpcHttpTranscoding {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GrpcHttpTranscoding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrpcHttpTranscoding): GrpcHttpTranscoding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.FileDescriptorSet file_descriptor_set */ 1:
                    message.fileDescriptorSet = FileDescriptorSet.internalBinaryRead(reader, reader.uint32(), options, message.fileDescriptorSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GrpcHttpTranscoding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.FileDescriptorSet file_descriptor_set = 1; */
        if (message.fileDescriptorSet)
            FileDescriptorSet.internalBinaryWrite(message.fileDescriptorSet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message foundation.schema.GrpcHttpTranscoding
 */
export const GrpcHttpTranscoding = new GrpcHttpTranscoding$Type();
