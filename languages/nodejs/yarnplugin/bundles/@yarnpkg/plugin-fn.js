/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-fn",
factory: function (require) {
var plugin=(()=>{var E=Object.create,l=Object.defineProperty,A=Object.defineProperties,C=Object.getOwnPropertyDescriptor,T=Object.getOwnPropertyDescriptors,_=Object.getOwnPropertyNames,P=Object.getOwnPropertySymbols,$=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var y=(t,e,o)=>e in t?l(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,R=(t,e)=>{for(var o in e||(e={}))v.call(e,o)&&y(t,o,e[o]);if(P)for(var o of P(e))x.call(e,o)&&y(t,o,e[o]);return t},k=(t,e)=>A(t,T(e)),S=t=>l(t,"__esModule",{value:!0});var p=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var I=(t,e)=>{for(var o in e)l(t,o,{get:e[o],enumerable:!0})},K=(t,e,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of _(e))!v.call(t,r)&&r!=="default"&&l(t,r,{get:()=>e[r],enumerable:!(o=C(e,r))||o.enumerable});return t},f=t=>K(S(l(t!=null?E($(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var b=(t,e,o)=>{if(!e.has(t))throw TypeError("Cannot "+o)};var d=(t,e,o)=>(b(t,e,"read from private field"),o?o.call(t):e.get(t)),u=(t,e,o)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,o)},m=(t,e,o,r)=>(b(t,e,"write to private field"),r?r.call(t,o):e.set(t,o),o);var W={};I(W,{default:()=>J});var w=f(p("@yarnpkg/core")),a=f(p("@yarnpkg/fslib")),M=f(p("fs"));var i="fn:",g="FN_YARN_LOCK_FILENAME";var h,c,O=class{constructor(){u(this,h,void 0);u(this,c,void 0);let e=process.env[g];if(!e)throw new Error(`Lock file can't be found: ${g} is not set.`);let o=(0,M.readFileSync)(e,"utf8"),r=JSON.parse(o);console.log(`lockFile: ${JSON.stringify(r,void 0,2)}`),m(this,c,r.modules||{}),m(this,h,r.rootPath)}supports(e,o){return e.reference.startsWith(i)}getLocalPath(e,o){let{selector:r}=w.structUtils.parseRange(e.reference);if(!r)throw new Error(`locator.reference can't be parsed: ${e.reference}`);for(let[s,N]of Object.entries(d(this,c)))if(r==s){let L=a.ppath.resolve(d(this,h),N.path);return console.log(`resolvedPath: ${L}`),L}throw new Error(`Package "${r}" couldn't be resolved. Known modules:
${JSON.stringify(d(this,c),void 0,2)}`)}async fetch(e,o){let r=this.getLocalPath(e,o);return{packageFs:new a.CwdFS(r),prefixPath:a.PortablePath.dot,localPath:r}}};h=new WeakMap,c=new WeakMap;var n=f(p("@yarnpkg/core")),D=f(p("@yarnpkg/fslib"));var F=class{supportsDescriptor(e,o){return e.range.startsWith(i)}supportsLocator(e,o){return e.reference.startsWith(i)}shouldPersistResolution(e,o){return!1}bindDescriptor(e,o,r){return e}getResolutionDependencies(e,o){return[]}async getCandidates(e,o,r){let s=e.range.slice(i.length);return[n.structUtils.makeLocator(e,`${i}${D.npath.toPortablePath(s)}`)]}async getSatisfying(e,o,r){return null}async resolve(e,o){if(!o.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let r=await o.fetchOptions.fetcher.fetch(e,o.fetchOptions),s=await n.miscUtils.releaseAfterUseAsync(async()=>await n.Manifest.find(r.prefixPath,{baseFs:r.packageFs}),r.releaseFs);return k(R({},e),{version:s.version||"0.0.0",languageName:s.languageName||o.project.configuration.get("defaultLanguageName"),linkType:n.LinkType.SOFT,conditions:s.getConditions(),dependencies:s.dependencies,peerDependencies:s.peerDependencies,dependenciesMeta:s.dependenciesMeta,peerDependenciesMeta:s.peerDependenciesMeta,bin:s.bin})}};var U={hooks:{afterAllInstalled:()=>{console.log("Foundation plugin installed")}},fetchers:[O],resolvers:[F]},J=U;return W;})();
return plugin;
}
};
